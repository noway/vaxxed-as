diff --git a/node_modules/react-data-fetching/cjs/react-data-fetching.js b/node_modules/react-data-fetching/cjs/react-data-fetching.js
index 4c6f34f..27f0b0a 100644
--- a/node_modules/react-data-fetching/cjs/react-data-fetching.js
+++ b/node_modules/react-data-fetching/cjs/react-data-fetching.js
@@ -1,1063 +1,64 @@
 'use strict';
 
-Object.defineProperty(exports, '__esModule', { value: true });
-
-var react = require('react');
-
-function createCommonjsModule(fn, module) {
-	return module = { exports: {} }, fn(module, module.exports), module.exports;
-}
-
-/*
-object-assign
-(c) Sindre Sorhus
-@license MIT
-*/
-/* eslint-disable no-unused-vars */
-var getOwnPropertySymbols = Object.getOwnPropertySymbols;
-var hasOwnProperty = Object.prototype.hasOwnProperty;
-var propIsEnumerable = Object.prototype.propertyIsEnumerable;
-
-function toObject(val) {
-	if (val === null || val === undefined) {
-		throw new TypeError('Object.assign cannot be called with null or undefined');
-	}
-
-	return Object(val);
-}
-
-function shouldUseNative() {
-	try {
-		if (!Object.assign) {
-			return false;
-		}
-
-		// Detect buggy property enumeration order in older V8 versions.
-
-		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
-		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
-		test1[5] = 'de';
-		if (Object.getOwnPropertyNames(test1)[0] === '5') {
-			return false;
-		}
-
-		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
-		var test2 = {};
-		for (var i = 0; i < 10; i++) {
-			test2['_' + String.fromCharCode(i)] = i;
-		}
-		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
-			return test2[n];
-		});
-		if (order2.join('') !== '0123456789') {
-			return false;
-		}
-
-		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
-		var test3 = {};
-		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
-			test3[letter] = letter;
-		});
-		if (Object.keys(Object.assign({}, test3)).join('') !==
-				'abcdefghijklmnopqrst') {
-			return false;
-		}
-
-		return true;
-	} catch (err) {
-		// We don't expect any of the above to throw, but better to be safe.
-		return false;
-	}
-}
-
-var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
-	var from;
-	var to = toObject(target);
-	var symbols;
-
-	for (var s = 1; s < arguments.length; s++) {
-		from = Object(arguments[s]);
-
-		for (var key in from) {
-			if (hasOwnProperty.call(from, key)) {
-				to[key] = from[key];
-			}
-		}
-
-		if (getOwnPropertySymbols) {
-			symbols = getOwnPropertySymbols(from);
-			for (var i = 0; i < symbols.length; i++) {
-				if (propIsEnumerable.call(from, symbols[i])) {
-					to[symbols[i]] = from[symbols[i]];
-				}
-			}
-		}
-	}
-
-	return to;
-};
-
-/**
- * Copyright (c) 2013-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
-
-var ReactPropTypesSecret_1 = ReactPropTypesSecret;
-
-var printWarning = function() {};
-
-if (process.env.NODE_ENV !== 'production') {
-  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
-  var loggedTypeFailures = {};
-
-  printWarning = function(text) {
-    var message = 'Warning: ' + text;
-    if (typeof console !== 'undefined') {
-      console.error(message);
-    }
-    try {
-      // --- Welcome to debugging React ---
-      // This error was thrown as a convenience so that you can use this stack
-      // to find the callsite that caused this warning to fire.
-      throw new Error(message);
-    } catch (x) {}
-  };
-}
-
-/**
- * Assert that the values match with the type specs.
- * Error messages are memorized and will only be shown once.
- *
- * @param {object} typeSpecs Map of name to a ReactPropType
- * @param {object} values Runtime values that need to be type-checked
- * @param {string} location e.g. "prop", "context", "child context"
- * @param {string} componentName Name of the component for error messages.
- * @param {?Function} getStack Returns the component stack.
- * @private
- */
-function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
-  if (process.env.NODE_ENV !== 'production') {
-    for (var typeSpecName in typeSpecs) {
-      if (typeSpecs.hasOwnProperty(typeSpecName)) {
-        var error;
-        // Prop type validation may throw. In case they do, we don't want to
-        // fail the render phase where it didn't fail before. So we log it.
-        // After these have been cleaned up, we'll let them throw.
-        try {
-          // This is intentionally an invariant that gets caught. It's the same
-          // behavior as without this statement except with a better message.
-          if (typeof typeSpecs[typeSpecName] !== 'function') {
-            var err = Error(
-              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
-              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
-            );
-            err.name = 'Invariant Violation';
-            throw err;
-          }
-          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
-        } catch (ex) {
-          error = ex;
-        }
-        if (error && !(error instanceof Error)) {
-          printWarning(
-            (componentName || 'React class') + ': type specification of ' +
-            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
-            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
-            'You may have forgotten to pass an argument to the type checker ' +
-            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
-            'shape all require an argument).'
-          );
-
-        }
-        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
-          // Only monitor this failure once because there tends to be a lot of the
-          // same error.
-          loggedTypeFailures[error.message] = true;
-
-          var stack = getStack ? getStack() : '';
-
-          printWarning(
-            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
-          );
-        }
-      }
-    }
-  }
-}
-
-var checkPropTypes_1 = checkPropTypes;
-
-var printWarning$1 = function() {};
-
-if (process.env.NODE_ENV !== 'production') {
-  printWarning$1 = function(text) {
-    var message = 'Warning: ' + text;
-    if (typeof console !== 'undefined') {
-      console.error(message);
-    }
-    try {
-      // --- Welcome to debugging React ---
-      // This error was thrown as a convenience so that you can use this stack
-      // to find the callsite that caused this warning to fire.
-      throw new Error(message);
-    } catch (x) {}
-  };
-}
-
-function emptyFunctionThatReturnsNull() {
-  return null;
-}
-
-var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
-  /* global Symbol */
-  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
-  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
-
-  /**
-   * Returns the iterator method function contained on the iterable object.
-   *
-   * Be sure to invoke the function with the iterable as context:
-   *
-   *     var iteratorFn = getIteratorFn(myIterable);
-   *     if (iteratorFn) {
-   *       var iterator = iteratorFn.call(myIterable);
-   *       ...
-   *     }
-   *
-   * @param {?object} maybeIterable
-   * @return {?function}
-   */
-  function getIteratorFn(maybeIterable) {
-    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
-    if (typeof iteratorFn === 'function') {
-      return iteratorFn;
-    }
-  }
-
-  /**
-   * Collection of methods that allow declaration and validation of props that are
-   * supplied to React components. Example usage:
-   *
-   *   var Props = require('ReactPropTypes');
-   *   var MyArticle = React.createClass({
-   *     propTypes: {
-   *       // An optional string prop named "description".
-   *       description: Props.string,
-   *
-   *       // A required enum prop named "category".
-   *       category: Props.oneOf(['News','Photos']).isRequired,
-   *
-   *       // A prop named "dialog" that requires an instance of Dialog.
-   *       dialog: Props.instanceOf(Dialog).isRequired
-   *     },
-   *     render: function() { ... }
-   *   });
-   *
-   * A more formal specification of how these methods are used:
-   *
-   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
-   *   decl := ReactPropTypes.{type}(.isRequired)?
-   *
-   * Each and every declaration produces a function with the same signature. This
-   * allows the creation of custom validation functions. For example:
-   *
-   *  var MyLink = React.createClass({
-   *    propTypes: {
-   *      // An optional string or URI prop named "href".
-   *      href: function(props, propName, componentName) {
-   *        var propValue = props[propName];
-   *        if (propValue != null && typeof propValue !== 'string' &&
-   *            !(propValue instanceof URI)) {
-   *          return new Error(
-   *            'Expected a string or an URI for ' + propName + ' in ' +
-   *            componentName
-   *          );
-   *        }
-   *      }
-   *    },
-   *    render: function() {...}
-   *  });
-   *
-   * @internal
-   */
-
-  var ANONYMOUS = '<<anonymous>>';
-
-  // Important!
-  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
-  var ReactPropTypes = {
-    array: createPrimitiveTypeChecker('array'),
-    bool: createPrimitiveTypeChecker('boolean'),
-    func: createPrimitiveTypeChecker('function'),
-    number: createPrimitiveTypeChecker('number'),
-    object: createPrimitiveTypeChecker('object'),
-    string: createPrimitiveTypeChecker('string'),
-    symbol: createPrimitiveTypeChecker('symbol'),
-
-    any: createAnyTypeChecker(),
-    arrayOf: createArrayOfTypeChecker,
-    element: createElementTypeChecker(),
-    instanceOf: createInstanceTypeChecker,
-    node: createNodeChecker(),
-    objectOf: createObjectOfTypeChecker,
-    oneOf: createEnumTypeChecker,
-    oneOfType: createUnionTypeChecker,
-    shape: createShapeTypeChecker,
-    exact: createStrictShapeTypeChecker,
-  };
-
-  /**
-   * inlined Object.is polyfill to avoid requiring consumers ship their own
-   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
-   */
-  /*eslint-disable no-self-compare*/
-  function is(x, y) {
-    // SameValue algorithm
-    if (x === y) {
-      // Steps 1-5, 7-10
-      // Steps 6.b-6.e: +0 != -0
-      return x !== 0 || 1 / x === 1 / y;
-    } else {
-      // Step 6.a: NaN == NaN
-      return x !== x && y !== y;
-    }
-  }
-  /*eslint-enable no-self-compare*/
-
-  /**
-   * We use an Error-like object for backward compatibility as people may call
-   * PropTypes directly and inspect their output. However, we don't use real
-   * Errors anymore. We don't inspect their stack anyway, and creating them
-   * is prohibitively expensive if they are created too often, such as what
-   * happens in oneOfType() for any type before the one that matched.
-   */
-  function PropTypeError(message) {
-    this.message = message;
-    this.stack = '';
-  }
-  // Make `instanceof Error` still work for returned errors.
-  PropTypeError.prototype = Error.prototype;
-
-  function createChainableTypeChecker(validate) {
-    if (process.env.NODE_ENV !== 'production') {
-      var manualPropTypeCallCache = {};
-      var manualPropTypeWarningCount = 0;
-    }
-    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
-      componentName = componentName || ANONYMOUS;
-      propFullName = propFullName || propName;
-
-      if (secret !== ReactPropTypesSecret_1) {
-        if (throwOnDirectAccess) {
-          // New behavior only for users of `prop-types` package
-          var err = new Error(
-            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
-            'Use `PropTypes.checkPropTypes()` to call them. ' +
-            'Read more at http://fb.me/use-check-prop-types'
-          );
-          err.name = 'Invariant Violation';
-          throw err;
-        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
-          // Old behavior for people using React.PropTypes
-          var cacheKey = componentName + ':' + propName;
-          if (
-            !manualPropTypeCallCache[cacheKey] &&
-            // Avoid spamming the console because they are often not actionable except for lib authors
-            manualPropTypeWarningCount < 3
-          ) {
-            printWarning$1(
-              'You are manually calling a React.PropTypes validation ' +
-              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
-              'and will throw in the standalone `prop-types` package. ' +
-              'You may be seeing this warning due to a third-party PropTypes ' +
-              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
-            );
-            manualPropTypeCallCache[cacheKey] = true;
-            manualPropTypeWarningCount++;
-          }
-        }
-      }
-      if (props[propName] == null) {
-        if (isRequired) {
-          if (props[propName] === null) {
-            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
-          }
-          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
-        }
-        return null;
-      } else {
-        return validate(props, propName, componentName, location, propFullName);
-      }
-    }
-
-    var chainedCheckType = checkType.bind(null, false);
-    chainedCheckType.isRequired = checkType.bind(null, true);
-
-    return chainedCheckType;
-  }
-
-  function createPrimitiveTypeChecker(expectedType) {
-    function validate(props, propName, componentName, location, propFullName, secret) {
-      var propValue = props[propName];
-      var propType = getPropType(propValue);
-      if (propType !== expectedType) {
-        // `propValue` being instance of, say, date/regexp, pass the 'object'
-        // check, but we can offer a more precise error message here rather than
-        // 'of type `object`'.
-        var preciseType = getPreciseType(propValue);
-
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createAnyTypeChecker() {
-    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
-  }
-
-  function createArrayOfTypeChecker(typeChecker) {
-    function validate(props, propName, componentName, location, propFullName) {
-      if (typeof typeChecker !== 'function') {
-        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
-      }
-      var propValue = props[propName];
-      if (!Array.isArray(propValue)) {
-        var propType = getPropType(propValue);
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
-      }
-      for (var i = 0; i < propValue.length; i++) {
-        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
-        if (error instanceof Error) {
-          return error;
-        }
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createElementTypeChecker() {
-    function validate(props, propName, componentName, location, propFullName) {
-      var propValue = props[propName];
-      if (!isValidElement(propValue)) {
-        var propType = getPropType(propValue);
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createInstanceTypeChecker(expectedClass) {
-    function validate(props, propName, componentName, location, propFullName) {
-      if (!(props[propName] instanceof expectedClass)) {
-        var expectedClassName = expectedClass.name || ANONYMOUS;
-        var actualClassName = getClassName(props[propName]);
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createEnumTypeChecker(expectedValues) {
-    if (!Array.isArray(expectedValues)) {
-      process.env.NODE_ENV !== 'production' ? printWarning$1('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
-      return emptyFunctionThatReturnsNull;
-    }
-
-    function validate(props, propName, componentName, location, propFullName) {
-      var propValue = props[propName];
-      for (var i = 0; i < expectedValues.length; i++) {
-        if (is(propValue, expectedValues[i])) {
-          return null;
-        }
-      }
-
-      var valuesString = JSON.stringify(expectedValues);
-      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createObjectOfTypeChecker(typeChecker) {
-    function validate(props, propName, componentName, location, propFullName) {
-      if (typeof typeChecker !== 'function') {
-        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
-      }
-      var propValue = props[propName];
-      var propType = getPropType(propValue);
-      if (propType !== 'object') {
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
-      }
-      for (var key in propValue) {
-        if (propValue.hasOwnProperty(key)) {
-          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
-          if (error instanceof Error) {
-            return error;
-          }
-        }
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createUnionTypeChecker(arrayOfTypeCheckers) {
-    if (!Array.isArray(arrayOfTypeCheckers)) {
-      process.env.NODE_ENV !== 'production' ? printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
-      return emptyFunctionThatReturnsNull;
-    }
-
-    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
-      var checker = arrayOfTypeCheckers[i];
-      if (typeof checker !== 'function') {
-        printWarning$1(
-          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
-          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
-        );
-        return emptyFunctionThatReturnsNull;
-      }
-    }
-
-    function validate(props, propName, componentName, location, propFullName) {
-      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
-        var checker = arrayOfTypeCheckers[i];
-        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
-          return null;
-        }
-      }
-
-      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createNodeChecker() {
-    function validate(props, propName, componentName, location, propFullName) {
-      if (!isNode(props[propName])) {
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createShapeTypeChecker(shapeTypes) {
-    function validate(props, propName, componentName, location, propFullName) {
-      var propValue = props[propName];
-      var propType = getPropType(propValue);
-      if (propType !== 'object') {
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
-      }
-      for (var key in shapeTypes) {
-        var checker = shapeTypes[key];
-        if (!checker) {
-          continue;
-        }
-        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
-        if (error) {
-          return error;
-        }
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createStrictShapeTypeChecker(shapeTypes) {
-    function validate(props, propName, componentName, location, propFullName) {
-      var propValue = props[propName];
-      var propType = getPropType(propValue);
-      if (propType !== 'object') {
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
-      }
-      // We need to check all keys in case some are required but missing from
-      // props.
-      var allKeys = objectAssign({}, props[propName], shapeTypes);
-      for (var key in allKeys) {
-        var checker = shapeTypes[key];
-        if (!checker) {
-          return new PropTypeError(
-            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
-            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
-            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
-          );
-        }
-        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
-        if (error) {
-          return error;
-        }
-      }
-      return null;
-    }
-
-    return createChainableTypeChecker(validate);
-  }
-
-  function isNode(propValue) {
-    switch (typeof propValue) {
-      case 'number':
-      case 'string':
-      case 'undefined':
-        return true;
-      case 'boolean':
-        return !propValue;
-      case 'object':
-        if (Array.isArray(propValue)) {
-          return propValue.every(isNode);
-        }
-        if (propValue === null || isValidElement(propValue)) {
-          return true;
-        }
-
-        var iteratorFn = getIteratorFn(propValue);
-        if (iteratorFn) {
-          var iterator = iteratorFn.call(propValue);
-          var step;
-          if (iteratorFn !== propValue.entries) {
-            while (!(step = iterator.next()).done) {
-              if (!isNode(step.value)) {
-                return false;
-              }
-            }
-          } else {
-            // Iterator will provide entry [k,v] tuples rather than values.
-            while (!(step = iterator.next()).done) {
-              var entry = step.value;
-              if (entry) {
-                if (!isNode(entry[1])) {
-                  return false;
-                }
-              }
-            }
-          }
-        } else {
-          return false;
-        }
-
-        return true;
-      default:
-        return false;
-    }
-  }
-
-  function isSymbol(propType, propValue) {
-    // Native Symbol.
-    if (propType === 'symbol') {
-      return true;
-    }
-
-    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
-    if (propValue['@@toStringTag'] === 'Symbol') {
-      return true;
-    }
-
-    // Fallback for non-spec compliant Symbols which are polyfilled.
-    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
-      return true;
-    }
-
-    return false;
-  }
-
-  // Equivalent of `typeof` but with special handling for array and regexp.
-  function getPropType(propValue) {
-    var propType = typeof propValue;
-    if (Array.isArray(propValue)) {
-      return 'array';
-    }
-    if (propValue instanceof RegExp) {
-      // Old webkits (at least until Android 4.0) return 'function' rather than
-      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
-      // passes PropTypes.object.
-      return 'object';
-    }
-    if (isSymbol(propType, propValue)) {
-      return 'symbol';
-    }
-    return propType;
-  }
-
-  // This handles more types than `getPropType`. Only used for error messages.
-  // See `createPrimitiveTypeChecker`.
-  function getPreciseType(propValue) {
-    if (typeof propValue === 'undefined' || propValue === null) {
-      return '' + propValue;
-    }
-    var propType = getPropType(propValue);
-    if (propType === 'object') {
-      if (propValue instanceof Date) {
-        return 'date';
-      } else if (propValue instanceof RegExp) {
-        return 'regexp';
-      }
-    }
-    return propType;
-  }
-
-  // Returns a string that is postfixed to a warning about an invalid type.
-  // For example, "undefined" or "of type array"
-  function getPostfixForTypeWarning(value) {
-    var type = getPreciseType(value);
-    switch (type) {
-      case 'array':
-      case 'object':
-        return 'an ' + type;
-      case 'boolean':
-      case 'date':
-      case 'regexp':
-        return 'a ' + type;
-      default:
-        return type;
-    }
+function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
+  try {
+    var info = gen[key](arg);
+    var value = info.value;
+  } catch (error) {
+    reject(error);
+    return;
   }
 
-  // Returns class name of the object, if any.
-  function getClassName(propValue) {
-    if (!propValue.constructor || !propValue.constructor.name) {
-      return ANONYMOUS;
-    }
-    return propValue.constructor.name;
+  if (info.done) {
+    resolve(value);
+  } else {
+    Promise.resolve(value).then(_next, _throw);
   }
-
-  ReactPropTypes.checkPropTypes = checkPropTypes_1;
-  ReactPropTypes.PropTypes = ReactPropTypes;
-
-  return ReactPropTypes;
-};
-
-function emptyFunction() {}
-
-var factoryWithThrowingShims = function() {
-  function shim(props, propName, componentName, location, propFullName, secret) {
-    if (secret === ReactPropTypesSecret_1) {
-      // It is still safe when called from React.
-      return;
-    }
-    var err = new Error(
-      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
-      'Use PropTypes.checkPropTypes() to call them. ' +
-      'Read more at http://fb.me/use-check-prop-types'
-    );
-    err.name = 'Invariant Violation';
-    throw err;
-  }  shim.isRequired = shim;
-  function getShim() {
-    return shim;
-  }  // Important!
-  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
-  var ReactPropTypes = {
-    array: shim,
-    bool: shim,
-    func: shim,
-    number: shim,
-    object: shim,
-    string: shim,
-    symbol: shim,
-
-    any: shim,
-    arrayOf: getShim,
-    element: shim,
-    instanceOf: getShim,
-    node: shim,
-    objectOf: getShim,
-    oneOf: getShim,
-    oneOfType: getShim,
-    shape: getShim,
-    exact: getShim
-  };
-
-  ReactPropTypes.checkPropTypes = emptyFunction;
-  ReactPropTypes.PropTypes = ReactPropTypes;
-
-  return ReactPropTypes;
-};
-
-var propTypes = createCommonjsModule(function (module) {
-/**
- * Copyright (c) 2013-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-if (process.env.NODE_ENV !== 'production') {
-  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
-    Symbol.for &&
-    Symbol.for('react.element')) ||
-    0xeac7;
-
-  var isValidElement = function(object) {
-    return typeof object === 'object' &&
-      object !== null &&
-      object.$$typeof === REACT_ELEMENT_TYPE;
-  };
-
-  // By explicitly using `prop-types` you are opting into new development behavior.
-  // http://fb.me/prop-types-in-prod
-  var throwOnDirectAccess = true;
-  module.exports = factoryWithTypeCheckers(isValidElement, throwOnDirectAccess);
-} else {
-  // By explicitly using `prop-types` you are opting into new production behavior.
-  // http://fb.me/prop-types-in-prod
-  module.exports = factoryWithThrowingShims();
 }
-});
-
-/**
- * Copyright (c) 2013-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-/**
- * Use invariant() to assert state which your program assumes to be true.
- *
- * Provide sprintf-style format (only %s is supported) and arguments
- * to provide information about what broke and what you were
- * expecting.
- *
- * The invariant message will be stripped in production, but the invariant
- * will remain to ensure logic does not differ in production.
- */
-
-var NODE_ENV = process.env.NODE_ENV;
-
-var invariant = function(condition, format, a, b, c, d, e, f) {
-  if (NODE_ENV !== 'production') {
-    if (format === undefined) {
-      throw new Error('invariant requires an error message argument');
-    }
-  }
-
-  if (!condition) {
-    var error;
-    if (format === undefined) {
-      error = new Error(
-        'Minified exception occurred; use the non-minified dev environment ' +
-        'for the full error message and additional helpful warnings.'
-      );
-    } else {
-      var args = [a, b, c, d, e, f];
-      var argIndex = 0;
-      error = new Error(
-        format.replace(/%s/g, function() { return args[argIndex++]; })
-      );
-      error.name = 'Invariant Violation';
-    }
-
-    error.framesToPop = 1; // we don't care about invariant's own frame
-    throw error;
-  }
-};
-
-var invariant_1 = invariant;
 
-// FLOW
-
-// PROPTYPES
-var methodShape = propTypes.oneOf(['DELETE', 'FORM_DATA', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'TRACE']);
-
-var storeShape = propTypes.shape({
-  getState: propTypes.func
-});
-
-var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
-  return typeof obj;
-} : function (obj) {
-  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
-};
-
-var asyncToGenerator = function (fn) {
+function _asyncToGenerator(fn) {
   return function () {
-    var gen = fn.apply(this, arguments);
+    var self = this,
+        args = arguments;
     return new Promise(function (resolve, reject) {
-      function step(key, arg) {
-        try {
-          var info = gen[key](arg);
-          var value = info.value;
-        } catch (error) {
-          reject(error);
-          return;
-        }
+      var gen = fn.apply(self, args);
 
-        if (info.done) {
-          resolve(value);
-        } else {
-          return Promise.resolve(value).then(function (value) {
-            step("next", value);
-          }, function (err) {
-            step("throw", err);
-          });
-        }
+      function _next(value) {
+        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
 
-      return step("next");
-    });
-  };
-};
-
-var classCallCheck = function (instance, Constructor) {
-  if (!(instance instanceof Constructor)) {
-    throw new TypeError("Cannot call a class as a function");
-  }
-};
-
-var _extends = Object.assign || function (target) {
-  for (var i = 1; i < arguments.length; i++) {
-    var source = arguments[i];
-
-    for (var key in source) {
-      if (Object.prototype.hasOwnProperty.call(source, key)) {
-        target[key] = source[key];
+      function _throw(err) {
+        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
-    }
-  }
-
-  return target;
-};
-
-var inherits = function (subClass, superClass) {
-  if (typeof superClass !== "function" && superClass !== null) {
-    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
-  }
-
-  subClass.prototype = Object.create(superClass && superClass.prototype, {
-    constructor: {
-      value: subClass,
-      enumerable: false,
-      writable: true,
-      configurable: true
-    }
-  });
-  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
-};
-
-var possibleConstructorReturn = function (self, call) {
-  if (!self) {
-    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
-  }
 
-  return call && (typeof call === "object" || typeof call === "function") ? call : self;
-};
-
-var _this2 = undefined;
-
-var createConnectedFetch = function createConnectedFetch() {
-  var ConnectedFetch = function (_Component) {
-    inherits(ConnectedFetch, _Component);
-
-    function ConnectedFetch() {
-      var _temp, _this, _ret;
+      _next(undefined);
+    });
+  };
+}
 
-      classCallCheck(this, ConnectedFetch);
+function _extends() {
+  _extends = Object.assign || function (target) {
+    for (var i = 1; i < arguments.length; i++) {
+      var source = arguments[i];
 
-      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
-        args[_key] = arguments[_key];
+      for (var key in source) {
+        if (Object.prototype.hasOwnProperty.call(source, key)) {
+          target[key] = source[key];
+        }
       }
-
-      return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.rdfApi = _this.props.api, _this.rdfHeaders = _this.props.headers, _this.rdfInterceptor = _this.props.onIntercept, _this.rdfLoader = _this.props.loader, _this.rdfStore = _this.context && _this.context.store ? _this.context.store.getState() : _this.props.store, _this.rdfTimeout = _this.props.timeout, _this.componentWillReceiveProps = function () {
-        return null;
-      }, _temp), possibleConstructorReturn(_this, _ret);
     }
 
-    ConnectedFetch.prototype.componentDidMount = function componentDidMount() {
-      var message = '`<ConnectedFetch />` is deprecated and will be removed ' + 'in the next major version. ' + 'Please use `<FetchProvider />` instead.';
-
-      if (process.env.NODE_ENV !== 'production') {
-        if (typeof console !== 'undefined') console.error(message);
-
-        try {
-          throw new Error(message);
-        } catch (x) {} // eslint-disable-line
-      }
-    };
-
-    ConnectedFetch.prototype.getChildContext = function getChildContext() {
-      return {
-        rdfApi: this.rdfApi || '',
-        rdfHeaders: this.rdfHeaders,
-        rdfInterceptor: this.rdfInterceptor,
-        rdfLoader: this.rdfLoader,
-        rdfStore: this.props.store || this.rdfStore,
-        rdfTimeout: this.rdfTimeout
-      };
-    };
-
-    ConnectedFetch.prototype.render = function render() {
-      return react.Children.only(this.props.children);
-    };
-
-    return ConnectedFetch;
-  }(react.Component);
-
-  ConnectedFetch.defaultProps = {
-    api: undefined,
-    headers: {},
-    loader: undefined,
-    onIntercept: undefined,
-    store: undefined,
-    timeout: undefined
-  };
-  ConnectedFetch.propTypes = {
-    api: propTypes.string,
-    children: propTypes.element.isRequired,
-    headers: propTypes.object,
-    loader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-    onIntercept: propTypes.func,
-    store: storeShape,
-    timeout: propTypes.number
+    return target;
   };
-  ConnectedFetch.contextTypes = {
-    store: storeShape
-  };
-  ConnectedFetch.childContextTypes = {
-    rdfApi: propTypes.string,
-    rdfHeaders: propTypes.object,
-    rdfInterceptor: propTypes.func,
-    rdfLoader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-    rdfStore: propTypes.object,
-    rdfTimeout: propTypes.number
-  };
-
-
-  if (process.env.NODE_ENV !== 'production') {
-    ConnectedFetch.prototype.componentWillReceiveProps = function (nextProps) {
-      !(
-      // $FlowFixMe
-      _this2.rdfApi === nextProps.api) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `api` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2.rdfHeaders === nextProps.headers) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `headers` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2.rdfLoader === nextProps.loader) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `loader` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2.rdfInterceptor === nextProps.onIntercept) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `onIntercept` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2.rdfStore === nextProps.store) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `store` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2.rdfTimeout === nextProps.timeout) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `timeout` on the fly.') : invariant_1(false) : void 0;
-    };
-  }
 
-  return ConnectedFetch;
-};
+  return _extends.apply(this, arguments);
+}
 
-var ConnectedFetch = createConnectedFetch();
+function createCommonjsModule(fn, module) {
+	return module = { exports: {} }, fn(module, module.exports), module.exports;
+}
 
-var runtime = createCommonjsModule(function (module) {
+var runtime_1 = createCommonjsModule(function (module) {
 /**
  * Copyright (c) 2014-present, Facebook, Inc.
  *
@@ -1065,30 +66,33 @@ var runtime = createCommonjsModule(function (module) {
  * LICENSE file in the root directory of this source tree.
  */
 
-!(function(global) {
+var runtime = (function (exports) {
 
   var Op = Object.prototype;
   var hasOwn = Op.hasOwnProperty;
-  var undefined; // More compressible than void 0.
+  var undefined$1; // More compressible than void 0.
   var $Symbol = typeof Symbol === "function" ? Symbol : {};
   var iteratorSymbol = $Symbol.iterator || "@@iterator";
   var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
   var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
-  var runtime = global.regeneratorRuntime;
-  if (runtime) {
-    {
-      // If regeneratorRuntime is defined globally and we're in a module,
-      // make the exports object identical to regeneratorRuntime.
-      module.exports = runtime;
-    }
-    // Don't bother evaluating the rest of this file if the runtime was
-    // already defined globally.
-    return;
-  }
 
-  // Define the runtime globally (as expected by generated code) as either
-  // module.exports (if we're in a module) or a new, empty object.
-  runtime = global.regeneratorRuntime = module.exports;
+  function define(obj, key, value) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+    return obj[key];
+  }
+  try {
+    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
+    define({}, "");
+  } catch (err) {
+    define = function(obj, key, value) {
+      return obj[key] = value;
+    };
+  }
 
   function wrap(innerFn, outerFn, self, tryLocsList) {
     // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
@@ -1102,7 +106,7 @@ var runtime = createCommonjsModule(function (module) {
 
     return generator;
   }
-  runtime.wrap = wrap;
+  exports.wrap = wrap;
 
   // Try/catch helper to minimize deoptimizations. Returns a completion
   // record like context.tryEntries[i].completion. This interface could
@@ -1160,20 +164,23 @@ var runtime = createCommonjsModule(function (module) {
     Generator.prototype = Object.create(IteratorPrototype);
   GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
   GeneratorFunctionPrototype.constructor = GeneratorFunction;
-  GeneratorFunctionPrototype[toStringTagSymbol] =
-    GeneratorFunction.displayName = "GeneratorFunction";
+  GeneratorFunction.displayName = define(
+    GeneratorFunctionPrototype,
+    toStringTagSymbol,
+    "GeneratorFunction"
+  );
 
   // Helper for defining the .next, .throw, and .return methods of the
   // Iterator interface in terms of a single ._invoke method.
   function defineIteratorMethods(prototype) {
     ["next", "throw", "return"].forEach(function(method) {
-      prototype[method] = function(arg) {
+      define(prototype, method, function(arg) {
         return this._invoke(method, arg);
-      };
+      });
     });
   }
 
-  runtime.isGeneratorFunction = function(genFun) {
+  exports.isGeneratorFunction = function(genFun) {
     var ctor = typeof genFun === "function" && genFun.constructor;
     return ctor
       ? ctor === GeneratorFunction ||
@@ -1183,14 +190,12 @@ var runtime = createCommonjsModule(function (module) {
       : false;
   };
 
-  runtime.mark = function(genFun) {
+  exports.mark = function(genFun) {
     if (Object.setPrototypeOf) {
       Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
     } else {
       genFun.__proto__ = GeneratorFunctionPrototype;
-      if (!(toStringTagSymbol in genFun)) {
-        genFun[toStringTagSymbol] = "GeneratorFunction";
-      }
+      define(genFun, toStringTagSymbol, "GeneratorFunction");
     }
     genFun.prototype = Object.create(Gp);
     return genFun;
@@ -1200,11 +205,11 @@ var runtime = createCommonjsModule(function (module) {
   // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
   // `hasOwn.call(value, "__await")` to determine if the yielded value is
   // meant to be awaited.
-  runtime.awrap = function(arg) {
+  exports.awrap = function(arg) {
     return { __await: arg };
   };
 
-  function AsyncIterator(generator) {
+  function AsyncIterator(generator, PromiseImpl) {
     function invoke(method, arg, resolve, reject) {
       var record = tryCatch(generator[method], generator, arg);
       if (record.type === "throw") {
@@ -1215,32 +220,24 @@ var runtime = createCommonjsModule(function (module) {
         if (value &&
             typeof value === "object" &&
             hasOwn.call(value, "__await")) {
-          return Promise.resolve(value.__await).then(function(value) {
+          return PromiseImpl.resolve(value.__await).then(function(value) {
             invoke("next", value, resolve, reject);
           }, function(err) {
             invoke("throw", err, resolve, reject);
           });
         }
 
-        return Promise.resolve(value).then(function(unwrapped) {
+        return PromiseImpl.resolve(value).then(function(unwrapped) {
           // When a yielded Promise is resolved, its final value becomes
           // the .value of the Promise<{value,done}> result for the
-          // current iteration. If the Promise is rejected, however, the
-          // result for this iteration will be rejected with the same
-          // reason. Note that rejections of yielded Promises are not
-          // thrown back into the generator function, as is the case
-          // when an awaited Promise is rejected. This difference in
-          // behavior between yield and await is important, because it
-          // allows the consumer to decide what to do with the yielded
-          // rejection (swallow it and continue, manually .throw it back
-          // into the generator, abandon iteration, whatever). With
-          // await, by contrast, there is no opportunity to examine the
-          // rejection reason outside the generator function, so the
-          // only option is to throw it from the await expression, and
-          // let the generator function handle the exception.
+          // current iteration.
           result.value = unwrapped;
           resolve(result);
-        }, reject);
+        }, function(error) {
+          // If a rejected Promise was yielded, throw the rejection back
+          // into the async generator function so it can be handled there.
+          return invoke("throw", error, resolve, reject);
+        });
       }
     }
 
@@ -1248,7 +245,7 @@ var runtime = createCommonjsModule(function (module) {
 
     function enqueue(method, arg) {
       function callInvokeWithMethodAndArg() {
-        return new Promise(function(resolve, reject) {
+        return new PromiseImpl(function(resolve, reject) {
           invoke(method, arg, resolve, reject);
         });
       }
@@ -1283,17 +280,20 @@ var runtime = createCommonjsModule(function (module) {
   AsyncIterator.prototype[asyncIteratorSymbol] = function () {
     return this;
   };
-  runtime.AsyncIterator = AsyncIterator;
+  exports.AsyncIterator = AsyncIterator;
 
   // Note that simple async functions are implemented on top of
   // AsyncIterator objects; they just return a Promise for the value of
   // the final result produced by the iterator.
-  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
+  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
+    if (PromiseImpl === void 0) PromiseImpl = Promise;
+
     var iter = new AsyncIterator(
-      wrap(innerFn, outerFn, self, tryLocsList)
+      wrap(innerFn, outerFn, self, tryLocsList),
+      PromiseImpl
     );
 
-    return runtime.isGeneratorFunction(outerFn)
+    return exports.isGeneratorFunction(outerFn)
       ? iter // If outerFn is a generator, return the full iterator.
       : iter.next().then(function(result) {
           return result.done ? result.value : iter.next();
@@ -1384,17 +384,18 @@ var runtime = createCommonjsModule(function (module) {
   // setting context.delegate to null, and returning the ContinueSentinel.
   function maybeInvokeDelegate(delegate, context) {
     var method = delegate.iterator[context.method];
-    if (method === undefined) {
+    if (method === undefined$1) {
       // A .throw or .return when the delegate iterator has no .throw
       // method always terminates the yield* loop.
       context.delegate = null;
 
       if (context.method === "throw") {
-        if (delegate.iterator.return) {
+        // Note: ["return"] must be used for ES3 parsing compatibility.
+        if (delegate.iterator["return"]) {
           // If the delegate iterator has a return method, give it a
           // chance to clean up.
           context.method = "return";
-          context.arg = undefined;
+          context.arg = undefined$1;
           maybeInvokeDelegate(delegate, context);
 
           if (context.method === "throw") {
@@ -1446,7 +447,7 @@ var runtime = createCommonjsModule(function (module) {
       // outer generator.
       if (context.method !== "return") {
         context.method = "next";
-        context.arg = undefined;
+        context.arg = undefined$1;
       }
 
     } else {
@@ -1464,7 +465,7 @@ var runtime = createCommonjsModule(function (module) {
   // unified ._invoke helper method.
   defineIteratorMethods(Gp);
 
-  Gp[toStringTagSymbol] = "Generator";
+  define(Gp, toStringTagSymbol, "Generator");
 
   // A Generator should always return itself as the iterator object when the
   // @@iterator function is called on it. Some browsers' implementations of the
@@ -1510,7 +511,7 @@ var runtime = createCommonjsModule(function (module) {
     this.reset(true);
   }
 
-  runtime.keys = function(object) {
+  exports.keys = function(object) {
     var keys = [];
     for (var key in object) {
       keys.push(key);
@@ -1558,7 +559,7 @@ var runtime = createCommonjsModule(function (module) {
             }
           }
 
-          next.value = undefined;
+          next.value = undefined$1;
           next.done = true;
 
           return next;
@@ -1571,10 +572,10 @@ var runtime = createCommonjsModule(function (module) {
     // Return an iterator with no values.
     return { next: doneResult };
   }
-  runtime.values = values;
+  exports.values = values;
 
   function doneResult() {
-    return { value: undefined, done: true };
+    return { value: undefined$1, done: true };
   }
 
   Context.prototype = {
@@ -1585,12 +586,12 @@ var runtime = createCommonjsModule(function (module) {
       this.next = 0;
       // Resetting context._sent for legacy support of Babel's
       // function.sent implementation.
-      this.sent = this._sent = undefined;
+      this.sent = this._sent = undefined$1;
       this.done = false;
       this.delegate = null;
 
       this.method = "next";
-      this.arg = undefined;
+      this.arg = undefined$1;
 
       this.tryEntries.forEach(resetTryEntry);
 
@@ -1600,7 +601,7 @@ var runtime = createCommonjsModule(function (module) {
           if (name.charAt(0) === "t" &&
               hasOwn.call(this, name) &&
               !isNaN(+name.slice(1))) {
-            this[name] = undefined;
+            this[name] = undefined$1;
           }
         }
       }
@@ -1633,7 +634,7 @@ var runtime = createCommonjsModule(function (module) {
           // If the dispatched exception was caught by a catch block,
           // then let that catch block handle the exception normally.
           context.method = "next";
-          context.arg = undefined;
+          context.arg = undefined$1;
         }
 
         return !! caught;
@@ -1770,66 +771,53 @@ var runtime = createCommonjsModule(function (module) {
       if (this.method === "next") {
         // Deliberately forget the last sent value so that we don't
         // accidentally pass it on to the delegate.
-        this.arg = undefined;
+        this.arg = undefined$1;
       }
 
       return ContinueSentinel;
     }
   };
-})(
-  // In sloppy mode, unbound `this` refers to the global object, fallback to
-  // Function constructor if we're in global strict mode. That is sadly a form
-  // of indirect eval which violates Content Security Policy.
-  (function() { return this })() || Function("return this")()
-);
-});
-
-/**
- * Copyright (c) 2014-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-// This method of obtaining a reference to the global object needs to be
-// kept identical to the way it is obtained in runtime.js
-var g = (function() { return this })() || Function("return this")();
-
-// Use `getOwnPropertyNames` because not all browsers support calling
-// `hasOwnProperty` on the global `self` object in a worker. See #183.
-var hadRuntime = g.regeneratorRuntime &&
-  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
 
-// Save the old regeneratorRuntime in case it needs to be restored later.
-var oldRuntime = hadRuntime && g.regeneratorRuntime;
-
-// Force reevalutation of runtime.js.
-g.regeneratorRuntime = undefined;
-
-var runtimeModule = runtime;
-
-if (hadRuntime) {
-  // Restore the original runtime.
-  g.regeneratorRuntime = oldRuntime;
-} else {
-  // Remove the global property added by runtime.js.
-  try {
-    delete g.regeneratorRuntime;
-  } catch(e) {
-    g.regeneratorRuntime = undefined;
-  }
+  // Regardless of whether this script is executing as a CommonJS module
+  // or not, return the runtime object so that we can declare the variable
+  // regeneratorRuntime in the outer scope, which allows this module to be
+  // injected easily by `bin/regenerator --include-runtime script.js`.
+  return exports;
+
+}(
+  // If this script is executing as a CommonJS module, use module.exports
+  // as the regeneratorRuntime namespace. Otherwise create a new empty
+  // object. Either way, the resulting object will be used to initialize
+  // the regeneratorRuntime variable at the top of this file.
+   module.exports 
+));
+
+try {
+  regeneratorRuntime = runtime;
+} catch (accidentalStrictMode) {
+  // This module should not be running in strict mode, so the above
+  // assignment should always work unless something is misconfigured. Just
+  // in case runtime.js accidentally runs in strict mode, we can escape
+  // strict mode using a global Function call. This could conceivably fail
+  // if a Content Security Policy forbids using Function, but in that case
+  // the proper solution is to fix the accidental strict mode problem. If
+  // you've misconfigured your bundler to force strict mode and applied a
+  // CSP to forbid Function, and you're not willing to fix either of those
+  // problems, please detail your unique predicament in a GitHub issue.
+  Function("r", "regeneratorRuntime = r")(runtime);
 }
+});
 
-var regenerator = runtimeModule;
-
-var _this = undefined;
+var regenerator = runtime_1;
 
+/* eslint no-return-assign: 0 */
 var requestToApi = function requestToApi(args) {
   var body = args.body,
+      cancel = args.cancel,
       headers = args.headers,
       method = args.method,
       _args$onProgress = args.onProgress,
-      onProgress = _args$onProgress === undefined ? function () {
+      onProgress = _args$onProgress === void 0 ? function () {
     return null;
   } : _args$onProgress,
       onTimeout = args.onTimeout,
@@ -1837,8 +825,8 @@ var requestToApi = function requestToApi(args) {
       onIntercept = args.onIntercept,
       url = args.url,
       _args$timeout = args.timeout,
-      timeout = _args$timeout === undefined ? 0 : _args$timeout;
-
+      timeout = _args$timeout === void 0 ? 0 : _args$timeout,
+      disableDefaultHeaders = args.disableDefaultHeaders;
   var defaultHeaders = {
     Accept: 'application/json;charset=UTF-8',
     'Content-Type': method === 'FORM_DATA' ? 'multipart/form-data' : 'application/json'
@@ -1847,8 +835,8 @@ var requestToApi = function requestToApi(args) {
   var route = url;
   var interceptedResult = null;
 
-  var handleError = function () {
-    var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(error, request, reject) {
+  var handleError = /*#__PURE__*/function () {
+    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(error, request, reject) {
       return regenerator.wrap(function _callee$(_context) {
         while (1) {
           switch (_context.prev = _context.next) {
@@ -1859,11 +847,11 @@ var requestToApi = function requestToApi(args) {
               });
 
             case 1:
-            case 'end':
+            case "end":
               return _context.stop();
           }
         }
-      }, _callee, _this);
+      }, _callee);
     }));
 
     return function handleError(_x, _x2, _x3) {
@@ -1874,66 +862,107 @@ var requestToApi = function requestToApi(args) {
   var handleTimeout = function handleTimeout(request, reject) {
     request.abort();
     if (onTimeout) onTimeout();
-    reject('Your request took more than ' + timeout + 'ms to resolve.');
+    reject("Your request took more than " + timeout + "ms to resolve.");
   };
 
-  var returnData = function () {
-    var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(request, resolve, reject) {
-      var isOK, data, response;
+  var returnData = /*#__PURE__*/function () {
+    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(request, resolve, reject, isCancel) {
+      var response, isOK, _response;
+
       return regenerator.wrap(function _callee2$(_context2) {
         while (1) {
           switch (_context2.prev = _context2.next) {
             case 0:
-              if (request.readyState === 4) {
-                isOK = request.status >= 200 && request.status <= 299;
-
-                if (isOK) {
-                  data = void 0;
-
-                  try {
-                    if (request.responseText) data = JSON.parse(request.responseText);
-                  } catch (err) {
-                    data = request.responseText;
-                  }
-                  response = {
-                    data: data,
-                    isOK: isOK,
-                    request: request,
-                    status: request.status
-                  };
-
-                  resolve(response);
-                } else if (onIntercept) {
-                  interceptedResult = onIntercept({
-                    currentParams: args,
-                    request: request,
-                    status: request.status
-                  });
-                  if (interceptedResult) {
-                    resolve(requestToApi(_extends({}, interceptedResult, {
-                      onIntercept: undefined
-                    })));
-                  } else handleError(request, request, reject);
-                } else handleError(request, request, reject);
+              if (isCancel) {
+                response = {
+                  data: {
+                    cancelled: true
+                  },
+                  isOK: true,
+                  request: request,
+                  status: request.status
+                };
+                resolve(response);
               }
 
-            case 1:
-            case 'end':
+              if (!(request.readyState === 4)) {
+                _context2.next = 20;
+                break;
+              }
+
+              isOK = request.status >= 200 && request.status <= 299;
+
+              if (!isOK) {
+                _context2.next = 19;
+                break;
+              }
+
+              if (!request.responseText) {
+                _context2.next = 10;
+                break;
+              }
+
+              _context2.next = 7;
+              return JSON.parse(request.responseText);
+
+            case 7:
+              _context2.t0 = _context2.sent;
+              _context2.next = 11;
+              break;
+
+            case 10:
+              _context2.t0 = undefined;
+
+            case 11:
+              _context2.t1 = _context2.t0;
+              _context2.t2 = isOK;
+              _context2.t3 = request;
+              _context2.t4 = request.status;
+              _response = {
+                data: _context2.t1,
+                isOK: _context2.t2,
+                request: _context2.t3,
+                status: _context2.t4
+              };
+              resolve(_response);
+              _context2.next = 20;
+              break;
+
+            case 19:
+              if (onIntercept) {
+                interceptedResult = onIntercept({
+                  currentParams: args,
+                  request: request,
+                  status: request.status
+                });
+
+                if (interceptedResult) {
+                  resolve(requestToApi(_extends({}, interceptedResult, {
+                    onIntercept: undefined
+                  })));
+                } else handleError(request, request, reject);
+              } else handleError(request, request, reject);
+
+            case 20:
+            case "end":
               return _context2.stop();
           }
         }
-      }, _callee2, _this);
+      }, _callee2);
     }));
 
-    return function returnData(_x4, _x5, _x6) {
+    return function returnData(_x4, _x5, _x6, _x7) {
       return _ref2.apply(this, arguments);
     };
   }();
 
   var setHeaders = function setHeaders(request) {
-    Object.entries(defaultHeaders).map(function (defaultHeader) {
-      return request.setRequestHeader(defaultHeader[0], String(defaultHeader[1]));
-    });
+    if (!disableDefaultHeaders) {
+      Object.entries(defaultHeaders).map(function (defaultHeader) {
+        return request.setRequestHeader(defaultHeader[0], String(defaultHeader[1]));
+      });
+    }
+
     if (headers && Object.keys(headers).length > 0) {
       Object.entries(headers).map(function (header) {
         return request.setRequestHeader(header[0], String(header[1]));
@@ -1942,8 +971,7 @@ var requestToApi = function requestToApi(args) {
   };
 
   if (method === 'FORM_DATA' && Object.entries(body).length > 0) {
-    Object.entries(body).map(
-    // $FlowFixMe
+    Object.entries(body).map( // $FlowFixMe
     function (entry) {
       return formData.append(entry[0], entry[1]);
     });
@@ -1951,7 +979,7 @@ var requestToApi = function requestToApi(args) {
 
   if (params && Object.keys(params).length > 0) {
     Object.entries(params).map(function (param, index) {
-      return index === 0 ? route = route + '?' + param[0] + '=' + JSON.stringify(param[1]) : route = route + '&' + param[0] + '=' + JSON.stringify(param[1]);
+      return index === 0 ? route = route + "?" + param[0] + "=" + JSON.stringify(param[1]) : route = route + "&" + param[0] + "=" + JSON.stringify(param[1]);
     });
   }
 
@@ -1959,14 +987,18 @@ var requestToApi = function requestToApi(args) {
     return new Promise(function (resolve, reject) {
       try {
         var request = new XMLHttpRequest();
+
         if (request.upload) {
           request.upload.onerror = function (error) {
             return handleError(error, request, resolve);
           };
+
           request.upload.onload = function () {
             return returnData(request, resolve, reject);
           };
+
           request.upload.onprogress = onProgress;
+
           request.upload.ontimeout = function () {
             return handleTimeout(request, reject);
           };
@@ -1975,10 +1007,13 @@ var requestToApi = function requestToApi(args) {
         request.onerror = function (error) {
           return handleError(error, request, resolve);
         };
+
         request.onprogress = onProgress;
+
         request.onreadystatechange = function () {
           return returnData(request, resolve, reject);
         };
+
         request.ontimeout = function () {
           return handleTimeout(request, reject);
         };
@@ -1986,7 +1021,9 @@ var requestToApi = function requestToApi(args) {
         request.open(method === 'FORM_DATA' ? 'POST' : method, route);
         request.timeout = timeout;
         setHeaders(request);
-        request.send(method === 'FORM_DATA' ? formData : method === 'DELETE' || method === 'GET' || method === 'HEAD' || method === 'PUT' ? null : JSON.stringify(_extends({}, body)));
+        if (cancel) returnData(request, resolve, reject, true);
+        request.send(method === 'FORM_DATA' ? formData : method === 'DELETE' || method === 'HEAD' ? null : JSON.stringify(_extends({}, body)));
+        if (cancel) request.abort();
       } catch (request) {
         handleError(request, request, reject);
       }
@@ -1996,403 +1033,4 @@ var requestToApi = function requestToApi(args) {
   return sendRequest();
 };
 
-var isEmptyChildren = function isEmptyChildren(children) {
-  return react.Children.count(children) === 0;
-};
-
-var Fetch = function (_Component) {
-  inherits(Fetch, _Component);
-
-  function Fetch() {
-    var _this2 = this;
-
-    var _temp, _this, _ret;
-
-    classCallCheck(this, Fetch);
-
-    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
-      args[_key] = arguments[_key];
-    }
-
-    return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this._data = undefined, _this._didCallOnLoad = false, _this._isLoaded = false, _this._isUnmounted = false, _this._fetchData = function () {
-      var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(props, context) {
-        var body, headers, method, onIntercept, onProgress, onTimeout, params, path, url, timeout, route, timeoutValue, apiResponse;
-        return regenerator.wrap(function _callee$(_context) {
-          while (1) {
-            switch (_context.prev = _context.next) {
-              case 0:
-                body = props.body, headers = props.headers, method = props.method, onIntercept = props.onIntercept, onProgress = props.onProgress, onTimeout = props.onTimeout, params = props.params, path = props.path, url = props.url, timeout = props.timeout;
-                route = void 0;
-                timeoutValue = 0;
-
-
-                if (path) route = '' + (context.rdfApi || '') + path;else route = url;
-
-                if (context.rdfTimeout && timeout === -1) timeoutValue = context.rdfTimeout;else if (!context.rdfTimeout && timeout) timeoutValue = Math.max(0, timeout);else if (context.rdfTimeout && timeout) timeoutValue = timeout === -1 ? context.rdfTimeout : timeout;
-
-                _context.prev = 5;
-                _context.next = 8;
-                return requestToApi({
-                  url: route || '',
-                  body: _extends({}, body),
-                  headers: _extends({}, context.rdfHeaders, headers),
-                  method: method,
-                  onTimeout: onTimeout,
-                  onProgress: onProgress,
-                  onIntercept: onIntercept || context.rdfInterceptor,
-                  params: _extends({}, params),
-                  timeout: timeoutValue
-                });
-
-              case 8:
-                apiResponse = _context.sent;
-
-                if (!_this._isUnmounted) {
-                  _this._handleData(_extends({}, apiResponse, {
-                    store: context.rdfStore
-                  }));
-                }
-                _context.next = 15;
-                break;
-
-              case 12:
-                _context.prev = 12;
-                _context.t0 = _context['catch'](5);
-
-                if (!_this._isUnmounted) {
-                  _this._handleData({
-                    error: {
-                      content: _context.t0,
-                      message: 'Something went wrong during the request',
-                      url: route
-                    },
-                    isOK: false,
-                    store: context.rdfStore
-                  });
-                  if (process.env.NODE_ENV !== 'production') {
-                    !!_context.t0 ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<Fetch /> tried to call the route "' + String(route) + '" ' + ('with "' + String(method).toUpperCase() + '" method ') + 'but resolved with the following error: %s\n', _this._printError(_context.t0)) : invariant_1(false) : void 0;
-                  }
-                }
-
-              case 15:
-              case 'end':
-                return _context.stop();
-            }
-          }
-        }, _callee, _this2, [[5, 12]]);
-      }));
-
-      return function (_x, _x2) {
-        return _ref.apply(this, arguments);
-      };
-    }(), _this._handleData = function (result) {
-      if (!_this._isUnmounted) {
-        _this._isLoaded = true;
-        _this.props.resultOnly ? _this._data = result.error || result.data : _this._data = result;
-        _this._returnData(result);
-      }
-    }, _this._printError = function (error) {
-      return error.response && JSON.stringify(error.response).length ? typeof error.response === 'string' ? error.response : _typeof(error.response) === 'object' ? JSON.stringify(error.response, null, 2) : error.response + '. Sorry <Fetch /> couldn\'t turned this into a readable string. ' + 'Check error.content.request to see what happened.' : " .Sorry <Fetch /> couldn't turned this into a readable string. " + 'Check error.content.request to see what happened.';
-    }, _this._renderLoader = function () {
-      var rdfLoader = _this.context.rdfLoader;
-      var loader = _this.props.loader;
-
-
-      if (rdfLoader && !loader) return typeof rdfLoader === 'function' ? rdfLoader() : rdfLoader;
-      if (!rdfLoader && loader) return typeof loader === 'function' ? loader() : loader;
-      if (rdfLoader && loader) return typeof loader === 'function' ? loader() : loader;
-
-      return null;
-    }, _this._returnData = function (result) {
-      var _this$props = _this.props,
-          onError = _this$props.onError,
-          onFetch = _this$props.onFetch;
-
-
-      if (onFetch) onFetch(_this._data);
-
-      if (result.error && onError) onError(_this._data);
-
-      if (!_this._isUnmounted) _this.forceUpdate();
-    }, _this._validateProps = function (props, context) {
-      var rdfApi = context.rdfApi,
-          rdfStore = context.rdfStore,
-          rdfTimeout = context.rdfTimeout;
-      var children = props.children,
-          component = props.component,
-          onTimeout = props.onTimeout,
-          onFetch = props.onFetch,
-          path = props.path,
-          refetch = props.refetch,
-          render = props.render,
-          timeout = props.timeout,
-          url = props.url;
-
-
-      !(path || url) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must provide a `url` or a `path` to <Fetch />') : invariant_1(false) : void 0;
-
-      if (path) {
-        !(path && rdfApi) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must implement <FetchProvider> at the root of your ' + 'app and provide an `api` in order to use `path`') : invariant_1(false) : void 0;
-      }
-
-      if (path === 'store') {
-        !(path && rdfStore) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must implement <FetchProvider> at the root of your ' + 'app and provide a `store` in order to use `path="store"`') : invariant_1(false) : void 0;
-      }
-
-      if (onTimeout) {
-        !(typeof timeout === 'number' && timeout >= 0 || typeof rdfTimeout === 'number' && rdfTimeout >= 0) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must provide a `timeout` number in ms to <Fetch /> or ' + '<FetchProvider> in order to use `onTimeout`') : invariant_1(false) : void 0;
-      }
-
-      !(children || component || render || onFetch) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must provide at least one of the following ' + 'to <Fetch />: children, `component`, `onFetch`, `render`') : invariant_1(false) : void 0;
-
-      if (typeof refetch !== 'undefined') {
-        var message = '`refetch` is deprecated and will be removed ' + 'in the next major version. ' + 'Please use `refetchKey` instead.';
-
-        if (process.env.NODE_ENV !== 'production') {
-          if (typeof console !== 'undefined') console.error(message);
-
-          try {
-            throw new Error(message);
-          } catch (x) {} // eslint-disable-line
-        }
-      }
-    }, _temp), possibleConstructorReturn(_this, _ret);
-  }
-
-  Fetch.prototype.componentWillMount = function componentWillMount() {
-    this._validateProps(this.props, this.context);
-    if (this.props.onLoad && !this._didCallOnLoad) {
-      this._didCallOnLoad = true;
-      this.props.onLoad();
-    }
-  };
-
-  Fetch.prototype.componentDidMount = function componentDidMount() {
-    if (this.props.path === 'store') {
-      this._handleData({
-        data: this.context.rdfStore,
-        isOK: true
-      });
-    } else this._fetchData(this.props, this.context);
-  };
-
-  Fetch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
-    var _props = this.props,
-        onLoad = _props.onLoad,
-        path = _props.path,
-        refetch = _props.refetch,
-        refetchKey = _props.refetchKey;
-
-
-    this._validateProps(nextProps, nextContext);
-
-    if (onLoad && !this._didCallOnLoad) {
-      this._didCallOnLoad = true;
-      onLoad();
-    }
-
-    if (path === 'store') {
-      this._handleData({
-        data: this.context.rdfStore,
-        isOK: true
-      });
-    } else if (nextProps.path !== path || nextProps.refetch !== refetch || nextProps.refetchKey !== refetchKey) {
-      this._isLoaded = false;
-      this._fetchData(nextProps, nextContext);
-    }
-  };
-
-  Fetch.prototype.componentWillUnmount = function componentWillUnmount() {
-    this._isUnmounted = true;
-  };
-
-  Fetch.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
-    if (this.props.children !== nextProps.children) return true;
-    if (this.props.loader !== nextProps.loader) return true;
-    if (this.props.onError !== nextProps.onError) return true;
-    if (this.props.onFetch !== nextProps.onFetch) return true;
-    if (this.props.onLoad !== nextProps.onLoad) return true;
-    if (this.props.path !== nextProps.path) return true;
-    if (this.props.params !== nextProps.params) return true;
-    if (this.props.refetch !== nextProps.refetch) return true;
-    if (this.props.refetchKey !== nextProps.refetchKey) return true;
-    if (this.props.render !== nextProps.render) return true;
-    if (this._isLoaded) return true;
-    if (this._data) return true;
-    return false;
-  };
-
-  Fetch.prototype.render = function render() {
-    var _props2 = this.props,
-        children = _props2.children,
-        component = _props2.component,
-        render = _props2.render;
-
-
-    if (!this._isLoaded && !this._isUnmounted) return this._renderLoader();
-
-    if (this._isLoaded && !this._isUnmounted) {
-      if (component) return react.createElement(component, this._data);
-
-      if (typeof render === 'function') return render(this._data);
-
-      if (typeof children === 'function') return children(this._data);
-
-      if (children && !isEmptyChildren(children)) return react.Children.only(children);
-    }
-
-    return null;
-  };
-
-  return Fetch;
-}(react.Component);
-
-Fetch.propTypes = {
-  body: propTypes.object,
-  children: propTypes.oneOfType([propTypes.element, propTypes.func]),
-  component: propTypes.oneOfType([propTypes.element, propTypes.func]),
-  method: methodShape,
-  loader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-  onError: propTypes.func,
-  onFetch: propTypes.func,
-  onLoad: propTypes.func,
-  onProgress: propTypes.func,
-  onTimeout: propTypes.func,
-  params: propTypes.object,
-  path: propTypes.string,
-  refetch: propTypes.any,
-  refetchKey: propTypes.any,
-  render: propTypes.func,
-  resultOnly: propTypes.bool,
-  url: propTypes.string,
-  timeout: propTypes.number
-};
-Fetch.contextTypes = {
-  rdfApi: propTypes.string,
-  rdfHeaders: propTypes.object,
-  rdfInterceptor: propTypes.func,
-  rdfLoader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-  rdfStore: propTypes.object,
-  rdfTimeout: propTypes.number
-};
-Fetch.defaultProps = {
-  body: {},
-  children: undefined,
-  component: undefined,
-  loader: undefined,
-  method: 'GET',
-  onError: undefined,
-  onFetch: undefined,
-  onLoad: undefined,
-  onProgress: undefined,
-  onTimeout: undefined,
-  params: {},
-  path: undefined,
-  refetch: undefined,
-  refetchKey: undefined,
-  render: undefined,
-  resultOnly: false,
-  url: undefined,
-  timeout: -1
-};
-
-var _this2$1 = undefined;
-
-var createFetchProvider = function createFetchProvider() {
-  var FetchProvider = function (_Component) {
-    inherits(FetchProvider, _Component);
-
-    function FetchProvider() {
-      var _temp, _this, _ret;
-
-      classCallCheck(this, FetchProvider);
-
-      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
-        args[_key] = arguments[_key];
-      }
-
-      return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.rdfApi = _this.props.api, _this.rdfHeaders = _this.props.headers, _this.rdfInterceptor = _this.props.onIntercept, _this.rdfLoader = _this.props.loader, _this.rdfStore = _this.context && _this.context.store ? _this.context.store.getState() : _this.props.store, _this.rdfTimeout = _this.props.timeout, _this.componentWillReceiveProps = function () {
-        return null;
-      }, _temp), possibleConstructorReturn(_this, _ret);
-    }
-
-    FetchProvider.prototype.getChildContext = function getChildContext() {
-      return {
-        rdfApi: this.rdfApi || '',
-        rdfHeaders: this.rdfHeaders,
-        rdfInterceptor: this.rdfInterceptor,
-        rdfLoader: this.rdfLoader,
-        rdfStore: this.props.store || this.rdfStore,
-        rdfTimeout: this.rdfTimeout
-      };
-    };
-
-    FetchProvider.prototype.render = function render() {
-      return react.Children.only(this.props.children);
-    };
-
-    return FetchProvider;
-  }(react.Component);
-
-  FetchProvider.defaultProps = {
-    api: undefined,
-    headers: {},
-    loader: undefined,
-    onIntercept: undefined,
-    store: undefined,
-    timeout: undefined
-  };
-  FetchProvider.propTypes = {
-    api: propTypes.string,
-    children: propTypes.element.isRequired,
-    headers: propTypes.object,
-    loader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-    onIntercept: propTypes.func,
-    store: storeShape,
-    timeout: propTypes.number
-  };
-  FetchProvider.contextTypes = {
-    store: storeShape
-  };
-  FetchProvider.childContextTypes = {
-    rdfApi: propTypes.string,
-    rdfHeaders: propTypes.object,
-    rdfInterceptor: propTypes.func,
-    rdfLoader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-    rdfStore: propTypes.object,
-    rdfTimeout: propTypes.number
-  };
-
-
-  if (process.env.NODE_ENV !== 'production') {
-    FetchProvider.prototype.componentWillReceiveProps = function (nextProps) {
-      !(
-      // $FlowFixMe
-      _this2$1.rdfApi === nextProps.api) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `api` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2$1.rdfHeaders === nextProps.headers) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `headers` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2$1.rdfLoader === nextProps.loader) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `loader` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2$1.rdfInterceptor === nextProps.onIntercept) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `onIntercept` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2$1.rdfStore === nextProps.store) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `store` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2$1.rdfTimeout === nextProps.timeout) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `timeout` on the fly.') : invariant_1(false) : void 0;
-    };
-  }
-
-  return FetchProvider;
-};
-
-var FetchProvider = createFetchProvider();
-
-exports.ConnectedFetch = ConnectedFetch;
-exports.Fetch = Fetch;
-exports.FetchProvider = FetchProvider;
-exports.requestToApi = requestToApi;
+module.exports = requestToApi;
diff --git a/node_modules/react-data-fetching/esm/react-data-fetching.js b/node_modules/react-data-fetching/esm/react-data-fetching.js
index 2b355cb..a721c2f 100644
--- a/node_modules/react-data-fetching/esm/react-data-fetching.js
+++ b/node_modules/react-data-fetching/esm/react-data-fetching.js
@@ -1,1059 +1,62 @@
-import { Children, Component, createElement } from 'react';
-
-function createCommonjsModule(fn, module) {
-	return module = { exports: {} }, fn(module, module.exports), module.exports;
-}
-
-/*
-object-assign
-(c) Sindre Sorhus
-@license MIT
-*/
-/* eslint-disable no-unused-vars */
-var getOwnPropertySymbols = Object.getOwnPropertySymbols;
-var hasOwnProperty = Object.prototype.hasOwnProperty;
-var propIsEnumerable = Object.prototype.propertyIsEnumerable;
-
-function toObject(val) {
-	if (val === null || val === undefined) {
-		throw new TypeError('Object.assign cannot be called with null or undefined');
-	}
-
-	return Object(val);
-}
-
-function shouldUseNative() {
-	try {
-		if (!Object.assign) {
-			return false;
-		}
-
-		// Detect buggy property enumeration order in older V8 versions.
-
-		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
-		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
-		test1[5] = 'de';
-		if (Object.getOwnPropertyNames(test1)[0] === '5') {
-			return false;
-		}
-
-		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
-		var test2 = {};
-		for (var i = 0; i < 10; i++) {
-			test2['_' + String.fromCharCode(i)] = i;
-		}
-		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
-			return test2[n];
-		});
-		if (order2.join('') !== '0123456789') {
-			return false;
-		}
-
-		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
-		var test3 = {};
-		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
-			test3[letter] = letter;
-		});
-		if (Object.keys(Object.assign({}, test3)).join('') !==
-				'abcdefghijklmnopqrst') {
-			return false;
-		}
-
-		return true;
-	} catch (err) {
-		// We don't expect any of the above to throw, but better to be safe.
-		return false;
-	}
-}
-
-var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
-	var from;
-	var to = toObject(target);
-	var symbols;
-
-	for (var s = 1; s < arguments.length; s++) {
-		from = Object(arguments[s]);
-
-		for (var key in from) {
-			if (hasOwnProperty.call(from, key)) {
-				to[key] = from[key];
-			}
-		}
-
-		if (getOwnPropertySymbols) {
-			symbols = getOwnPropertySymbols(from);
-			for (var i = 0; i < symbols.length; i++) {
-				if (propIsEnumerable.call(from, symbols[i])) {
-					to[symbols[i]] = from[symbols[i]];
-				}
-			}
-		}
-	}
-
-	return to;
-};
-
-/**
- * Copyright (c) 2013-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
-
-var ReactPropTypesSecret_1 = ReactPropTypesSecret;
-
-var printWarning = function() {};
-
-if (process.env.NODE_ENV !== 'production') {
-  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
-  var loggedTypeFailures = {};
-
-  printWarning = function(text) {
-    var message = 'Warning: ' + text;
-    if (typeof console !== 'undefined') {
-      console.error(message);
-    }
-    try {
-      // --- Welcome to debugging React ---
-      // This error was thrown as a convenience so that you can use this stack
-      // to find the callsite that caused this warning to fire.
-      throw new Error(message);
-    } catch (x) {}
-  };
-}
-
-/**
- * Assert that the values match with the type specs.
- * Error messages are memorized and will only be shown once.
- *
- * @param {object} typeSpecs Map of name to a ReactPropType
- * @param {object} values Runtime values that need to be type-checked
- * @param {string} location e.g. "prop", "context", "child context"
- * @param {string} componentName Name of the component for error messages.
- * @param {?Function} getStack Returns the component stack.
- * @private
- */
-function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
-  if (process.env.NODE_ENV !== 'production') {
-    for (var typeSpecName in typeSpecs) {
-      if (typeSpecs.hasOwnProperty(typeSpecName)) {
-        var error;
-        // Prop type validation may throw. In case they do, we don't want to
-        // fail the render phase where it didn't fail before. So we log it.
-        // After these have been cleaned up, we'll let them throw.
-        try {
-          // This is intentionally an invariant that gets caught. It's the same
-          // behavior as without this statement except with a better message.
-          if (typeof typeSpecs[typeSpecName] !== 'function') {
-            var err = Error(
-              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
-              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
-            );
-            err.name = 'Invariant Violation';
-            throw err;
-          }
-          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
-        } catch (ex) {
-          error = ex;
-        }
-        if (error && !(error instanceof Error)) {
-          printWarning(
-            (componentName || 'React class') + ': type specification of ' +
-            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
-            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
-            'You may have forgotten to pass an argument to the type checker ' +
-            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
-            'shape all require an argument).'
-          );
-
-        }
-        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
-          // Only monitor this failure once because there tends to be a lot of the
-          // same error.
-          loggedTypeFailures[error.message] = true;
-
-          var stack = getStack ? getStack() : '';
-
-          printWarning(
-            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
-          );
-        }
-      }
-    }
-  }
-}
-
-var checkPropTypes_1 = checkPropTypes;
-
-var printWarning$1 = function() {};
-
-if (process.env.NODE_ENV !== 'production') {
-  printWarning$1 = function(text) {
-    var message = 'Warning: ' + text;
-    if (typeof console !== 'undefined') {
-      console.error(message);
-    }
-    try {
-      // --- Welcome to debugging React ---
-      // This error was thrown as a convenience so that you can use this stack
-      // to find the callsite that caused this warning to fire.
-      throw new Error(message);
-    } catch (x) {}
-  };
-}
-
-function emptyFunctionThatReturnsNull() {
-  return null;
-}
-
-var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
-  /* global Symbol */
-  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
-  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
-
-  /**
-   * Returns the iterator method function contained on the iterable object.
-   *
-   * Be sure to invoke the function with the iterable as context:
-   *
-   *     var iteratorFn = getIteratorFn(myIterable);
-   *     if (iteratorFn) {
-   *       var iterator = iteratorFn.call(myIterable);
-   *       ...
-   *     }
-   *
-   * @param {?object} maybeIterable
-   * @return {?function}
-   */
-  function getIteratorFn(maybeIterable) {
-    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
-    if (typeof iteratorFn === 'function') {
-      return iteratorFn;
-    }
-  }
-
-  /**
-   * Collection of methods that allow declaration and validation of props that are
-   * supplied to React components. Example usage:
-   *
-   *   var Props = require('ReactPropTypes');
-   *   var MyArticle = React.createClass({
-   *     propTypes: {
-   *       // An optional string prop named "description".
-   *       description: Props.string,
-   *
-   *       // A required enum prop named "category".
-   *       category: Props.oneOf(['News','Photos']).isRequired,
-   *
-   *       // A prop named "dialog" that requires an instance of Dialog.
-   *       dialog: Props.instanceOf(Dialog).isRequired
-   *     },
-   *     render: function() { ... }
-   *   });
-   *
-   * A more formal specification of how these methods are used:
-   *
-   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
-   *   decl := ReactPropTypes.{type}(.isRequired)?
-   *
-   * Each and every declaration produces a function with the same signature. This
-   * allows the creation of custom validation functions. For example:
-   *
-   *  var MyLink = React.createClass({
-   *    propTypes: {
-   *      // An optional string or URI prop named "href".
-   *      href: function(props, propName, componentName) {
-   *        var propValue = props[propName];
-   *        if (propValue != null && typeof propValue !== 'string' &&
-   *            !(propValue instanceof URI)) {
-   *          return new Error(
-   *            'Expected a string or an URI for ' + propName + ' in ' +
-   *            componentName
-   *          );
-   *        }
-   *      }
-   *    },
-   *    render: function() {...}
-   *  });
-   *
-   * @internal
-   */
-
-  var ANONYMOUS = '<<anonymous>>';
-
-  // Important!
-  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
-  var ReactPropTypes = {
-    array: createPrimitiveTypeChecker('array'),
-    bool: createPrimitiveTypeChecker('boolean'),
-    func: createPrimitiveTypeChecker('function'),
-    number: createPrimitiveTypeChecker('number'),
-    object: createPrimitiveTypeChecker('object'),
-    string: createPrimitiveTypeChecker('string'),
-    symbol: createPrimitiveTypeChecker('symbol'),
-
-    any: createAnyTypeChecker(),
-    arrayOf: createArrayOfTypeChecker,
-    element: createElementTypeChecker(),
-    instanceOf: createInstanceTypeChecker,
-    node: createNodeChecker(),
-    objectOf: createObjectOfTypeChecker,
-    oneOf: createEnumTypeChecker,
-    oneOfType: createUnionTypeChecker,
-    shape: createShapeTypeChecker,
-    exact: createStrictShapeTypeChecker,
-  };
-
-  /**
-   * inlined Object.is polyfill to avoid requiring consumers ship their own
-   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
-   */
-  /*eslint-disable no-self-compare*/
-  function is(x, y) {
-    // SameValue algorithm
-    if (x === y) {
-      // Steps 1-5, 7-10
-      // Steps 6.b-6.e: +0 != -0
-      return x !== 0 || 1 / x === 1 / y;
-    } else {
-      // Step 6.a: NaN == NaN
-      return x !== x && y !== y;
-    }
-  }
-  /*eslint-enable no-self-compare*/
-
-  /**
-   * We use an Error-like object for backward compatibility as people may call
-   * PropTypes directly and inspect their output. However, we don't use real
-   * Errors anymore. We don't inspect their stack anyway, and creating them
-   * is prohibitively expensive if they are created too often, such as what
-   * happens in oneOfType() for any type before the one that matched.
-   */
-  function PropTypeError(message) {
-    this.message = message;
-    this.stack = '';
-  }
-  // Make `instanceof Error` still work for returned errors.
-  PropTypeError.prototype = Error.prototype;
-
-  function createChainableTypeChecker(validate) {
-    if (process.env.NODE_ENV !== 'production') {
-      var manualPropTypeCallCache = {};
-      var manualPropTypeWarningCount = 0;
-    }
-    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
-      componentName = componentName || ANONYMOUS;
-      propFullName = propFullName || propName;
-
-      if (secret !== ReactPropTypesSecret_1) {
-        if (throwOnDirectAccess) {
-          // New behavior only for users of `prop-types` package
-          var err = new Error(
-            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
-            'Use `PropTypes.checkPropTypes()` to call them. ' +
-            'Read more at http://fb.me/use-check-prop-types'
-          );
-          err.name = 'Invariant Violation';
-          throw err;
-        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
-          // Old behavior for people using React.PropTypes
-          var cacheKey = componentName + ':' + propName;
-          if (
-            !manualPropTypeCallCache[cacheKey] &&
-            // Avoid spamming the console because they are often not actionable except for lib authors
-            manualPropTypeWarningCount < 3
-          ) {
-            printWarning$1(
-              'You are manually calling a React.PropTypes validation ' +
-              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
-              'and will throw in the standalone `prop-types` package. ' +
-              'You may be seeing this warning due to a third-party PropTypes ' +
-              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
-            );
-            manualPropTypeCallCache[cacheKey] = true;
-            manualPropTypeWarningCount++;
-          }
-        }
-      }
-      if (props[propName] == null) {
-        if (isRequired) {
-          if (props[propName] === null) {
-            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
-          }
-          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
-        }
-        return null;
-      } else {
-        return validate(props, propName, componentName, location, propFullName);
-      }
-    }
-
-    var chainedCheckType = checkType.bind(null, false);
-    chainedCheckType.isRequired = checkType.bind(null, true);
-
-    return chainedCheckType;
-  }
-
-  function createPrimitiveTypeChecker(expectedType) {
-    function validate(props, propName, componentName, location, propFullName, secret) {
-      var propValue = props[propName];
-      var propType = getPropType(propValue);
-      if (propType !== expectedType) {
-        // `propValue` being instance of, say, date/regexp, pass the 'object'
-        // check, but we can offer a more precise error message here rather than
-        // 'of type `object`'.
-        var preciseType = getPreciseType(propValue);
-
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createAnyTypeChecker() {
-    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
-  }
-
-  function createArrayOfTypeChecker(typeChecker) {
-    function validate(props, propName, componentName, location, propFullName) {
-      if (typeof typeChecker !== 'function') {
-        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
-      }
-      var propValue = props[propName];
-      if (!Array.isArray(propValue)) {
-        var propType = getPropType(propValue);
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
-      }
-      for (var i = 0; i < propValue.length; i++) {
-        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
-        if (error instanceof Error) {
-          return error;
-        }
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createElementTypeChecker() {
-    function validate(props, propName, componentName, location, propFullName) {
-      var propValue = props[propName];
-      if (!isValidElement(propValue)) {
-        var propType = getPropType(propValue);
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createInstanceTypeChecker(expectedClass) {
-    function validate(props, propName, componentName, location, propFullName) {
-      if (!(props[propName] instanceof expectedClass)) {
-        var expectedClassName = expectedClass.name || ANONYMOUS;
-        var actualClassName = getClassName(props[propName]);
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createEnumTypeChecker(expectedValues) {
-    if (!Array.isArray(expectedValues)) {
-      process.env.NODE_ENV !== 'production' ? printWarning$1('Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
-      return emptyFunctionThatReturnsNull;
-    }
-
-    function validate(props, propName, componentName, location, propFullName) {
-      var propValue = props[propName];
-      for (var i = 0; i < expectedValues.length; i++) {
-        if (is(propValue, expectedValues[i])) {
-          return null;
-        }
-      }
-
-      var valuesString = JSON.stringify(expectedValues);
-      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createObjectOfTypeChecker(typeChecker) {
-    function validate(props, propName, componentName, location, propFullName) {
-      if (typeof typeChecker !== 'function') {
-        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
-      }
-      var propValue = props[propName];
-      var propType = getPropType(propValue);
-      if (propType !== 'object') {
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
-      }
-      for (var key in propValue) {
-        if (propValue.hasOwnProperty(key)) {
-          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
-          if (error instanceof Error) {
-            return error;
-          }
-        }
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createUnionTypeChecker(arrayOfTypeCheckers) {
-    if (!Array.isArray(arrayOfTypeCheckers)) {
-      process.env.NODE_ENV !== 'production' ? printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
-      return emptyFunctionThatReturnsNull;
-    }
-
-    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
-      var checker = arrayOfTypeCheckers[i];
-      if (typeof checker !== 'function') {
-        printWarning$1(
-          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
-          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
-        );
-        return emptyFunctionThatReturnsNull;
-      }
-    }
-
-    function validate(props, propName, componentName, location, propFullName) {
-      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
-        var checker = arrayOfTypeCheckers[i];
-        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
-          return null;
-        }
-      }
-
-      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createNodeChecker() {
-    function validate(props, propName, componentName, location, propFullName) {
-      if (!isNode(props[propName])) {
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createShapeTypeChecker(shapeTypes) {
-    function validate(props, propName, componentName, location, propFullName) {
-      var propValue = props[propName];
-      var propType = getPropType(propValue);
-      if (propType !== 'object') {
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
-      }
-      for (var key in shapeTypes) {
-        var checker = shapeTypes[key];
-        if (!checker) {
-          continue;
-        }
-        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
-        if (error) {
-          return error;
-        }
-      }
-      return null;
-    }
-    return createChainableTypeChecker(validate);
-  }
-
-  function createStrictShapeTypeChecker(shapeTypes) {
-    function validate(props, propName, componentName, location, propFullName) {
-      var propValue = props[propName];
-      var propType = getPropType(propValue);
-      if (propType !== 'object') {
-        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
-      }
-      // We need to check all keys in case some are required but missing from
-      // props.
-      var allKeys = objectAssign({}, props[propName], shapeTypes);
-      for (var key in allKeys) {
-        var checker = shapeTypes[key];
-        if (!checker) {
-          return new PropTypeError(
-            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
-            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
-            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
-          );
-        }
-        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
-        if (error) {
-          return error;
-        }
-      }
-      return null;
-    }
-
-    return createChainableTypeChecker(validate);
-  }
-
-  function isNode(propValue) {
-    switch (typeof propValue) {
-      case 'number':
-      case 'string':
-      case 'undefined':
-        return true;
-      case 'boolean':
-        return !propValue;
-      case 'object':
-        if (Array.isArray(propValue)) {
-          return propValue.every(isNode);
-        }
-        if (propValue === null || isValidElement(propValue)) {
-          return true;
-        }
-
-        var iteratorFn = getIteratorFn(propValue);
-        if (iteratorFn) {
-          var iterator = iteratorFn.call(propValue);
-          var step;
-          if (iteratorFn !== propValue.entries) {
-            while (!(step = iterator.next()).done) {
-              if (!isNode(step.value)) {
-                return false;
-              }
-            }
-          } else {
-            // Iterator will provide entry [k,v] tuples rather than values.
-            while (!(step = iterator.next()).done) {
-              var entry = step.value;
-              if (entry) {
-                if (!isNode(entry[1])) {
-                  return false;
-                }
-              }
-            }
-          }
-        } else {
-          return false;
-        }
-
-        return true;
-      default:
-        return false;
-    }
-  }
-
-  function isSymbol(propType, propValue) {
-    // Native Symbol.
-    if (propType === 'symbol') {
-      return true;
-    }
-
-    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
-    if (propValue['@@toStringTag'] === 'Symbol') {
-      return true;
-    }
-
-    // Fallback for non-spec compliant Symbols which are polyfilled.
-    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
-      return true;
-    }
-
-    return false;
-  }
-
-  // Equivalent of `typeof` but with special handling for array and regexp.
-  function getPropType(propValue) {
-    var propType = typeof propValue;
-    if (Array.isArray(propValue)) {
-      return 'array';
-    }
-    if (propValue instanceof RegExp) {
-      // Old webkits (at least until Android 4.0) return 'function' rather than
-      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
-      // passes PropTypes.object.
-      return 'object';
-    }
-    if (isSymbol(propType, propValue)) {
-      return 'symbol';
-    }
-    return propType;
-  }
-
-  // This handles more types than `getPropType`. Only used for error messages.
-  // See `createPrimitiveTypeChecker`.
-  function getPreciseType(propValue) {
-    if (typeof propValue === 'undefined' || propValue === null) {
-      return '' + propValue;
-    }
-    var propType = getPropType(propValue);
-    if (propType === 'object') {
-      if (propValue instanceof Date) {
-        return 'date';
-      } else if (propValue instanceof RegExp) {
-        return 'regexp';
-      }
-    }
-    return propType;
-  }
-
-  // Returns a string that is postfixed to a warning about an invalid type.
-  // For example, "undefined" or "of type array"
-  function getPostfixForTypeWarning(value) {
-    var type = getPreciseType(value);
-    switch (type) {
-      case 'array':
-      case 'object':
-        return 'an ' + type;
-      case 'boolean':
-      case 'date':
-      case 'regexp':
-        return 'a ' + type;
-      default:
-        return type;
-    }
+function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
+  try {
+    var info = gen[key](arg);
+    var value = info.value;
+  } catch (error) {
+    reject(error);
+    return;
   }
 
-  // Returns class name of the object, if any.
-  function getClassName(propValue) {
-    if (!propValue.constructor || !propValue.constructor.name) {
-      return ANONYMOUS;
-    }
-    return propValue.constructor.name;
+  if (info.done) {
+    resolve(value);
+  } else {
+    Promise.resolve(value).then(_next, _throw);
   }
-
-  ReactPropTypes.checkPropTypes = checkPropTypes_1;
-  ReactPropTypes.PropTypes = ReactPropTypes;
-
-  return ReactPropTypes;
-};
-
-function emptyFunction() {}
-
-var factoryWithThrowingShims = function() {
-  function shim(props, propName, componentName, location, propFullName, secret) {
-    if (secret === ReactPropTypesSecret_1) {
-      // It is still safe when called from React.
-      return;
-    }
-    var err = new Error(
-      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
-      'Use PropTypes.checkPropTypes() to call them. ' +
-      'Read more at http://fb.me/use-check-prop-types'
-    );
-    err.name = 'Invariant Violation';
-    throw err;
-  }  shim.isRequired = shim;
-  function getShim() {
-    return shim;
-  }  // Important!
-  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
-  var ReactPropTypes = {
-    array: shim,
-    bool: shim,
-    func: shim,
-    number: shim,
-    object: shim,
-    string: shim,
-    symbol: shim,
-
-    any: shim,
-    arrayOf: getShim,
-    element: shim,
-    instanceOf: getShim,
-    node: shim,
-    objectOf: getShim,
-    oneOf: getShim,
-    oneOfType: getShim,
-    shape: getShim,
-    exact: getShim
-  };
-
-  ReactPropTypes.checkPropTypes = emptyFunction;
-  ReactPropTypes.PropTypes = ReactPropTypes;
-
-  return ReactPropTypes;
-};
-
-var propTypes = createCommonjsModule(function (module) {
-/**
- * Copyright (c) 2013-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-if (process.env.NODE_ENV !== 'production') {
-  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
-    Symbol.for &&
-    Symbol.for('react.element')) ||
-    0xeac7;
-
-  var isValidElement = function(object) {
-    return typeof object === 'object' &&
-      object !== null &&
-      object.$$typeof === REACT_ELEMENT_TYPE;
-  };
-
-  // By explicitly using `prop-types` you are opting into new development behavior.
-  // http://fb.me/prop-types-in-prod
-  var throwOnDirectAccess = true;
-  module.exports = factoryWithTypeCheckers(isValidElement, throwOnDirectAccess);
-} else {
-  // By explicitly using `prop-types` you are opting into new production behavior.
-  // http://fb.me/prop-types-in-prod
-  module.exports = factoryWithThrowingShims();
 }
-});
-
-/**
- * Copyright (c) 2013-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-/**
- * Use invariant() to assert state which your program assumes to be true.
- *
- * Provide sprintf-style format (only %s is supported) and arguments
- * to provide information about what broke and what you were
- * expecting.
- *
- * The invariant message will be stripped in production, but the invariant
- * will remain to ensure logic does not differ in production.
- */
-
-var NODE_ENV = process.env.NODE_ENV;
-
-var invariant = function(condition, format, a, b, c, d, e, f) {
-  if (NODE_ENV !== 'production') {
-    if (format === undefined) {
-      throw new Error('invariant requires an error message argument');
-    }
-  }
-
-  if (!condition) {
-    var error;
-    if (format === undefined) {
-      error = new Error(
-        'Minified exception occurred; use the non-minified dev environment ' +
-        'for the full error message and additional helpful warnings.'
-      );
-    } else {
-      var args = [a, b, c, d, e, f];
-      var argIndex = 0;
-      error = new Error(
-        format.replace(/%s/g, function() { return args[argIndex++]; })
-      );
-      error.name = 'Invariant Violation';
-    }
-
-    error.framesToPop = 1; // we don't care about invariant's own frame
-    throw error;
-  }
-};
-
-var invariant_1 = invariant;
 
-// FLOW
-
-// PROPTYPES
-var methodShape = propTypes.oneOf(['DELETE', 'FORM_DATA', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'TRACE']);
-
-var storeShape = propTypes.shape({
-  getState: propTypes.func
-});
-
-var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
-  return typeof obj;
-} : function (obj) {
-  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
-};
-
-var asyncToGenerator = function (fn) {
+function _asyncToGenerator(fn) {
   return function () {
-    var gen = fn.apply(this, arguments);
+    var self = this,
+        args = arguments;
     return new Promise(function (resolve, reject) {
-      function step(key, arg) {
-        try {
-          var info = gen[key](arg);
-          var value = info.value;
-        } catch (error) {
-          reject(error);
-          return;
-        }
+      var gen = fn.apply(self, args);
 
-        if (info.done) {
-          resolve(value);
-        } else {
-          return Promise.resolve(value).then(function (value) {
-            step("next", value);
-          }, function (err) {
-            step("throw", err);
-          });
-        }
+      function _next(value) {
+        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
       }
 
-      return step("next");
-    });
-  };
-};
-
-var classCallCheck = function (instance, Constructor) {
-  if (!(instance instanceof Constructor)) {
-    throw new TypeError("Cannot call a class as a function");
-  }
-};
-
-var _extends = Object.assign || function (target) {
-  for (var i = 1; i < arguments.length; i++) {
-    var source = arguments[i];
-
-    for (var key in source) {
-      if (Object.prototype.hasOwnProperty.call(source, key)) {
-        target[key] = source[key];
+      function _throw(err) {
+        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
       }
-    }
-  }
-
-  return target;
-};
-
-var inherits = function (subClass, superClass) {
-  if (typeof superClass !== "function" && superClass !== null) {
-    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
-  }
-
-  subClass.prototype = Object.create(superClass && superClass.prototype, {
-    constructor: {
-      value: subClass,
-      enumerable: false,
-      writable: true,
-      configurable: true
-    }
-  });
-  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
-};
-
-var possibleConstructorReturn = function (self, call) {
-  if (!self) {
-    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
-  }
 
-  return call && (typeof call === "object" || typeof call === "function") ? call : self;
-};
-
-var _this2 = undefined;
-
-var createConnectedFetch = function createConnectedFetch() {
-  var ConnectedFetch = function (_Component) {
-    inherits(ConnectedFetch, _Component);
-
-    function ConnectedFetch() {
-      var _temp, _this, _ret;
+      _next(undefined);
+    });
+  };
+}
 
-      classCallCheck(this, ConnectedFetch);
+function _extends() {
+  _extends = Object.assign || function (target) {
+    for (var i = 1; i < arguments.length; i++) {
+      var source = arguments[i];
 
-      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
-        args[_key] = arguments[_key];
+      for (var key in source) {
+        if (Object.prototype.hasOwnProperty.call(source, key)) {
+          target[key] = source[key];
+        }
       }
-
-      return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.rdfApi = _this.props.api, _this.rdfHeaders = _this.props.headers, _this.rdfInterceptor = _this.props.onIntercept, _this.rdfLoader = _this.props.loader, _this.rdfStore = _this.context && _this.context.store ? _this.context.store.getState() : _this.props.store, _this.rdfTimeout = _this.props.timeout, _this.componentWillReceiveProps = function () {
-        return null;
-      }, _temp), possibleConstructorReturn(_this, _ret);
     }
 
-    ConnectedFetch.prototype.componentDidMount = function componentDidMount() {
-      var message = '`<ConnectedFetch />` is deprecated and will be removed ' + 'in the next major version. ' + 'Please use `<FetchProvider />` instead.';
-
-      if (process.env.NODE_ENV !== 'production') {
-        if (typeof console !== 'undefined') console.error(message);
-
-        try {
-          throw new Error(message);
-        } catch (x) {} // eslint-disable-line
-      }
-    };
-
-    ConnectedFetch.prototype.getChildContext = function getChildContext() {
-      return {
-        rdfApi: this.rdfApi || '',
-        rdfHeaders: this.rdfHeaders,
-        rdfInterceptor: this.rdfInterceptor,
-        rdfLoader: this.rdfLoader,
-        rdfStore: this.props.store || this.rdfStore,
-        rdfTimeout: this.rdfTimeout
-      };
-    };
-
-    ConnectedFetch.prototype.render = function render() {
-      return Children.only(this.props.children);
-    };
-
-    return ConnectedFetch;
-  }(Component);
-
-  ConnectedFetch.defaultProps = {
-    api: undefined,
-    headers: {},
-    loader: undefined,
-    onIntercept: undefined,
-    store: undefined,
-    timeout: undefined
-  };
-  ConnectedFetch.propTypes = {
-    api: propTypes.string,
-    children: propTypes.element.isRequired,
-    headers: propTypes.object,
-    loader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-    onIntercept: propTypes.func,
-    store: storeShape,
-    timeout: propTypes.number
+    return target;
   };
-  ConnectedFetch.contextTypes = {
-    store: storeShape
-  };
-  ConnectedFetch.childContextTypes = {
-    rdfApi: propTypes.string,
-    rdfHeaders: propTypes.object,
-    rdfInterceptor: propTypes.func,
-    rdfLoader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-    rdfStore: propTypes.object,
-    rdfTimeout: propTypes.number
-  };
-
-
-  if (process.env.NODE_ENV !== 'production') {
-    ConnectedFetch.prototype.componentWillReceiveProps = function (nextProps) {
-      !(
-      // $FlowFixMe
-      _this2.rdfApi === nextProps.api) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `api` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2.rdfHeaders === nextProps.headers) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `headers` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2.rdfLoader === nextProps.loader) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `loader` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2.rdfInterceptor === nextProps.onIntercept) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `onIntercept` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2.rdfStore === nextProps.store) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `store` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2.rdfTimeout === nextProps.timeout) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `timeout` on the fly.') : invariant_1(false) : void 0;
-    };
-  }
 
-  return ConnectedFetch;
-};
+  return _extends.apply(this, arguments);
+}
 
-var ConnectedFetch = createConnectedFetch();
+function createCommonjsModule(fn, module) {
+	return module = { exports: {} }, fn(module, module.exports), module.exports;
+}
 
-var runtime = createCommonjsModule(function (module) {
+var runtime_1 = createCommonjsModule(function (module) {
 /**
  * Copyright (c) 2014-present, Facebook, Inc.
  *
@@ -1061,30 +64,33 @@ var runtime = createCommonjsModule(function (module) {
  * LICENSE file in the root directory of this source tree.
  */
 
-!(function(global) {
+var runtime = (function (exports) {
 
   var Op = Object.prototype;
   var hasOwn = Op.hasOwnProperty;
-  var undefined; // More compressible than void 0.
+  var undefined$1; // More compressible than void 0.
   var $Symbol = typeof Symbol === "function" ? Symbol : {};
   var iteratorSymbol = $Symbol.iterator || "@@iterator";
   var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
   var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
-  var runtime = global.regeneratorRuntime;
-  if (runtime) {
-    {
-      // If regeneratorRuntime is defined globally and we're in a module,
-      // make the exports object identical to regeneratorRuntime.
-      module.exports = runtime;
-    }
-    // Don't bother evaluating the rest of this file if the runtime was
-    // already defined globally.
-    return;
-  }
 
-  // Define the runtime globally (as expected by generated code) as either
-  // module.exports (if we're in a module) or a new, empty object.
-  runtime = global.regeneratorRuntime = module.exports;
+  function define(obj, key, value) {
+    Object.defineProperty(obj, key, {
+      value: value,
+      enumerable: true,
+      configurable: true,
+      writable: true
+    });
+    return obj[key];
+  }
+  try {
+    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
+    define({}, "");
+  } catch (err) {
+    define = function(obj, key, value) {
+      return obj[key] = value;
+    };
+  }
 
   function wrap(innerFn, outerFn, self, tryLocsList) {
     // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
@@ -1098,7 +104,7 @@ var runtime = createCommonjsModule(function (module) {
 
     return generator;
   }
-  runtime.wrap = wrap;
+  exports.wrap = wrap;
 
   // Try/catch helper to minimize deoptimizations. Returns a completion
   // record like context.tryEntries[i].completion. This interface could
@@ -1156,20 +162,23 @@ var runtime = createCommonjsModule(function (module) {
     Generator.prototype = Object.create(IteratorPrototype);
   GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
   GeneratorFunctionPrototype.constructor = GeneratorFunction;
-  GeneratorFunctionPrototype[toStringTagSymbol] =
-    GeneratorFunction.displayName = "GeneratorFunction";
+  GeneratorFunction.displayName = define(
+    GeneratorFunctionPrototype,
+    toStringTagSymbol,
+    "GeneratorFunction"
+  );
 
   // Helper for defining the .next, .throw, and .return methods of the
   // Iterator interface in terms of a single ._invoke method.
   function defineIteratorMethods(prototype) {
     ["next", "throw", "return"].forEach(function(method) {
-      prototype[method] = function(arg) {
+      define(prototype, method, function(arg) {
         return this._invoke(method, arg);
-      };
+      });
     });
   }
 
-  runtime.isGeneratorFunction = function(genFun) {
+  exports.isGeneratorFunction = function(genFun) {
     var ctor = typeof genFun === "function" && genFun.constructor;
     return ctor
       ? ctor === GeneratorFunction ||
@@ -1179,14 +188,12 @@ var runtime = createCommonjsModule(function (module) {
       : false;
   };
 
-  runtime.mark = function(genFun) {
+  exports.mark = function(genFun) {
     if (Object.setPrototypeOf) {
       Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
     } else {
       genFun.__proto__ = GeneratorFunctionPrototype;
-      if (!(toStringTagSymbol in genFun)) {
-        genFun[toStringTagSymbol] = "GeneratorFunction";
-      }
+      define(genFun, toStringTagSymbol, "GeneratorFunction");
     }
     genFun.prototype = Object.create(Gp);
     return genFun;
@@ -1196,11 +203,11 @@ var runtime = createCommonjsModule(function (module) {
   // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
   // `hasOwn.call(value, "__await")` to determine if the yielded value is
   // meant to be awaited.
-  runtime.awrap = function(arg) {
+  exports.awrap = function(arg) {
     return { __await: arg };
   };
 
-  function AsyncIterator(generator) {
+  function AsyncIterator(generator, PromiseImpl) {
     function invoke(method, arg, resolve, reject) {
       var record = tryCatch(generator[method], generator, arg);
       if (record.type === "throw") {
@@ -1211,32 +218,24 @@ var runtime = createCommonjsModule(function (module) {
         if (value &&
             typeof value === "object" &&
             hasOwn.call(value, "__await")) {
-          return Promise.resolve(value.__await).then(function(value) {
+          return PromiseImpl.resolve(value.__await).then(function(value) {
             invoke("next", value, resolve, reject);
           }, function(err) {
             invoke("throw", err, resolve, reject);
           });
         }
 
-        return Promise.resolve(value).then(function(unwrapped) {
+        return PromiseImpl.resolve(value).then(function(unwrapped) {
           // When a yielded Promise is resolved, its final value becomes
           // the .value of the Promise<{value,done}> result for the
-          // current iteration. If the Promise is rejected, however, the
-          // result for this iteration will be rejected with the same
-          // reason. Note that rejections of yielded Promises are not
-          // thrown back into the generator function, as is the case
-          // when an awaited Promise is rejected. This difference in
-          // behavior between yield and await is important, because it
-          // allows the consumer to decide what to do with the yielded
-          // rejection (swallow it and continue, manually .throw it back
-          // into the generator, abandon iteration, whatever). With
-          // await, by contrast, there is no opportunity to examine the
-          // rejection reason outside the generator function, so the
-          // only option is to throw it from the await expression, and
-          // let the generator function handle the exception.
+          // current iteration.
           result.value = unwrapped;
           resolve(result);
-        }, reject);
+        }, function(error) {
+          // If a rejected Promise was yielded, throw the rejection back
+          // into the async generator function so it can be handled there.
+          return invoke("throw", error, resolve, reject);
+        });
       }
     }
 
@@ -1244,7 +243,7 @@ var runtime = createCommonjsModule(function (module) {
 
     function enqueue(method, arg) {
       function callInvokeWithMethodAndArg() {
-        return new Promise(function(resolve, reject) {
+        return new PromiseImpl(function(resolve, reject) {
           invoke(method, arg, resolve, reject);
         });
       }
@@ -1279,17 +278,20 @@ var runtime = createCommonjsModule(function (module) {
   AsyncIterator.prototype[asyncIteratorSymbol] = function () {
     return this;
   };
-  runtime.AsyncIterator = AsyncIterator;
+  exports.AsyncIterator = AsyncIterator;
 
   // Note that simple async functions are implemented on top of
   // AsyncIterator objects; they just return a Promise for the value of
   // the final result produced by the iterator.
-  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
+  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
+    if (PromiseImpl === void 0) PromiseImpl = Promise;
+
     var iter = new AsyncIterator(
-      wrap(innerFn, outerFn, self, tryLocsList)
+      wrap(innerFn, outerFn, self, tryLocsList),
+      PromiseImpl
     );
 
-    return runtime.isGeneratorFunction(outerFn)
+    return exports.isGeneratorFunction(outerFn)
       ? iter // If outerFn is a generator, return the full iterator.
       : iter.next().then(function(result) {
           return result.done ? result.value : iter.next();
@@ -1380,17 +382,18 @@ var runtime = createCommonjsModule(function (module) {
   // setting context.delegate to null, and returning the ContinueSentinel.
   function maybeInvokeDelegate(delegate, context) {
     var method = delegate.iterator[context.method];
-    if (method === undefined) {
+    if (method === undefined$1) {
       // A .throw or .return when the delegate iterator has no .throw
       // method always terminates the yield* loop.
       context.delegate = null;
 
       if (context.method === "throw") {
-        if (delegate.iterator.return) {
+        // Note: ["return"] must be used for ES3 parsing compatibility.
+        if (delegate.iterator["return"]) {
           // If the delegate iterator has a return method, give it a
           // chance to clean up.
           context.method = "return";
-          context.arg = undefined;
+          context.arg = undefined$1;
           maybeInvokeDelegate(delegate, context);
 
           if (context.method === "throw") {
@@ -1442,7 +445,7 @@ var runtime = createCommonjsModule(function (module) {
       // outer generator.
       if (context.method !== "return") {
         context.method = "next";
-        context.arg = undefined;
+        context.arg = undefined$1;
       }
 
     } else {
@@ -1460,7 +463,7 @@ var runtime = createCommonjsModule(function (module) {
   // unified ._invoke helper method.
   defineIteratorMethods(Gp);
 
-  Gp[toStringTagSymbol] = "Generator";
+  define(Gp, toStringTagSymbol, "Generator");
 
   // A Generator should always return itself as the iterator object when the
   // @@iterator function is called on it. Some browsers' implementations of the
@@ -1506,7 +509,7 @@ var runtime = createCommonjsModule(function (module) {
     this.reset(true);
   }
 
-  runtime.keys = function(object) {
+  exports.keys = function(object) {
     var keys = [];
     for (var key in object) {
       keys.push(key);
@@ -1554,7 +557,7 @@ var runtime = createCommonjsModule(function (module) {
             }
           }
 
-          next.value = undefined;
+          next.value = undefined$1;
           next.done = true;
 
           return next;
@@ -1567,10 +570,10 @@ var runtime = createCommonjsModule(function (module) {
     // Return an iterator with no values.
     return { next: doneResult };
   }
-  runtime.values = values;
+  exports.values = values;
 
   function doneResult() {
-    return { value: undefined, done: true };
+    return { value: undefined$1, done: true };
   }
 
   Context.prototype = {
@@ -1581,12 +584,12 @@ var runtime = createCommonjsModule(function (module) {
       this.next = 0;
       // Resetting context._sent for legacy support of Babel's
       // function.sent implementation.
-      this.sent = this._sent = undefined;
+      this.sent = this._sent = undefined$1;
       this.done = false;
       this.delegate = null;
 
       this.method = "next";
-      this.arg = undefined;
+      this.arg = undefined$1;
 
       this.tryEntries.forEach(resetTryEntry);
 
@@ -1596,7 +599,7 @@ var runtime = createCommonjsModule(function (module) {
           if (name.charAt(0) === "t" &&
               hasOwn.call(this, name) &&
               !isNaN(+name.slice(1))) {
-            this[name] = undefined;
+            this[name] = undefined$1;
           }
         }
       }
@@ -1629,7 +632,7 @@ var runtime = createCommonjsModule(function (module) {
           // If the dispatched exception was caught by a catch block,
           // then let that catch block handle the exception normally.
           context.method = "next";
-          context.arg = undefined;
+          context.arg = undefined$1;
         }
 
         return !! caught;
@@ -1766,66 +769,53 @@ var runtime = createCommonjsModule(function (module) {
       if (this.method === "next") {
         // Deliberately forget the last sent value so that we don't
         // accidentally pass it on to the delegate.
-        this.arg = undefined;
+        this.arg = undefined$1;
       }
 
       return ContinueSentinel;
     }
   };
-})(
-  // In sloppy mode, unbound `this` refers to the global object, fallback to
-  // Function constructor if we're in global strict mode. That is sadly a form
-  // of indirect eval which violates Content Security Policy.
-  (function() { return this })() || Function("return this")()
-);
-});
-
-/**
- * Copyright (c) 2014-present, Facebook, Inc.
- *
- * This source code is licensed under the MIT license found in the
- * LICENSE file in the root directory of this source tree.
- */
-
-// This method of obtaining a reference to the global object needs to be
-// kept identical to the way it is obtained in runtime.js
-var g = (function() { return this })() || Function("return this")();
-
-// Use `getOwnPropertyNames` because not all browsers support calling
-// `hasOwnProperty` on the global `self` object in a worker. See #183.
-var hadRuntime = g.regeneratorRuntime &&
-  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
 
-// Save the old regeneratorRuntime in case it needs to be restored later.
-var oldRuntime = hadRuntime && g.regeneratorRuntime;
-
-// Force reevalutation of runtime.js.
-g.regeneratorRuntime = undefined;
-
-var runtimeModule = runtime;
-
-if (hadRuntime) {
-  // Restore the original runtime.
-  g.regeneratorRuntime = oldRuntime;
-} else {
-  // Remove the global property added by runtime.js.
-  try {
-    delete g.regeneratorRuntime;
-  } catch(e) {
-    g.regeneratorRuntime = undefined;
-  }
+  // Regardless of whether this script is executing as a CommonJS module
+  // or not, return the runtime object so that we can declare the variable
+  // regeneratorRuntime in the outer scope, which allows this module to be
+  // injected easily by `bin/regenerator --include-runtime script.js`.
+  return exports;
+
+}(
+  // If this script is executing as a CommonJS module, use module.exports
+  // as the regeneratorRuntime namespace. Otherwise create a new empty
+  // object. Either way, the resulting object will be used to initialize
+  // the regeneratorRuntime variable at the top of this file.
+   module.exports 
+));
+
+try {
+  regeneratorRuntime = runtime;
+} catch (accidentalStrictMode) {
+  // This module should not be running in strict mode, so the above
+  // assignment should always work unless something is misconfigured. Just
+  // in case runtime.js accidentally runs in strict mode, we can escape
+  // strict mode using a global Function call. This could conceivably fail
+  // if a Content Security Policy forbids using Function, but in that case
+  // the proper solution is to fix the accidental strict mode problem. If
+  // you've misconfigured your bundler to force strict mode and applied a
+  // CSP to forbid Function, and you're not willing to fix either of those
+  // problems, please detail your unique predicament in a GitHub issue.
+  Function("r", "regeneratorRuntime = r")(runtime);
 }
+});
 
-var regenerator = runtimeModule;
-
-var _this = undefined;
+var regenerator = runtime_1;
 
+/* eslint no-return-assign: 0 */
 var requestToApi = function requestToApi(args) {
   var body = args.body,
+      cancel = args.cancel,
       headers = args.headers,
       method = args.method,
       _args$onProgress = args.onProgress,
-      onProgress = _args$onProgress === undefined ? function () {
+      onProgress = _args$onProgress === void 0 ? function () {
     return null;
   } : _args$onProgress,
       onTimeout = args.onTimeout,
@@ -1833,8 +823,8 @@ var requestToApi = function requestToApi(args) {
       onIntercept = args.onIntercept,
       url = args.url,
       _args$timeout = args.timeout,
-      timeout = _args$timeout === undefined ? 0 : _args$timeout;
-
+      timeout = _args$timeout === void 0 ? 0 : _args$timeout,
+      disableDefaultHeaders = args.disableDefaultHeaders;
   var defaultHeaders = {
     Accept: 'application/json;charset=UTF-8',
     'Content-Type': method === 'FORM_DATA' ? 'multipart/form-data' : 'application/json'
@@ -1843,8 +833,8 @@ var requestToApi = function requestToApi(args) {
   var route = url;
   var interceptedResult = null;
 
-  var handleError = function () {
-    var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(error, request, reject) {
+  var handleError = /*#__PURE__*/function () {
+    var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(error, request, reject) {
       return regenerator.wrap(function _callee$(_context) {
         while (1) {
           switch (_context.prev = _context.next) {
@@ -1855,11 +845,11 @@ var requestToApi = function requestToApi(args) {
               });
 
             case 1:
-            case 'end':
+            case "end":
               return _context.stop();
           }
         }
-      }, _callee, _this);
+      }, _callee);
     }));
 
     return function handleError(_x, _x2, _x3) {
@@ -1870,66 +860,107 @@ var requestToApi = function requestToApi(args) {
   var handleTimeout = function handleTimeout(request, reject) {
     request.abort();
     if (onTimeout) onTimeout();
-    reject('Your request took more than ' + timeout + 'ms to resolve.');
+    reject("Your request took more than " + timeout + "ms to resolve.");
   };
 
-  var returnData = function () {
-    var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(request, resolve, reject) {
-      var isOK, data, response;
+  var returnData = /*#__PURE__*/function () {
+    var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(request, resolve, reject, isCancel) {
+      var response, isOK, _response;
+
       return regenerator.wrap(function _callee2$(_context2) {
         while (1) {
           switch (_context2.prev = _context2.next) {
             case 0:
-              if (request.readyState === 4) {
-                isOK = request.status >= 200 && request.status <= 299;
-
-                if (isOK) {
-                  data = void 0;
-
-                  try {
-                    if (request.responseText) data = JSON.parse(request.responseText);
-                  } catch (err) {
-                    data = request.responseText;
-                  }
-                  response = {
-                    data: data,
-                    isOK: isOK,
-                    request: request,
-                    status: request.status
-                  };
-
-                  resolve(response);
-                } else if (onIntercept) {
-                  interceptedResult = onIntercept({
-                    currentParams: args,
-                    request: request,
-                    status: request.status
-                  });
-                  if (interceptedResult) {
-                    resolve(requestToApi(_extends({}, interceptedResult, {
-                      onIntercept: undefined
-                    })));
-                  } else handleError(request, request, reject);
-                } else handleError(request, request, reject);
+              if (isCancel) {
+                response = {
+                  data: {
+                    cancelled: true
+                  },
+                  isOK: true,
+                  request: request,
+                  status: request.status
+                };
+                resolve(response);
               }
 
-            case 1:
-            case 'end':
+              if (!(request.readyState === 4)) {
+                _context2.next = 20;
+                break;
+              }
+
+              isOK = request.status >= 200 && request.status <= 299;
+
+              if (!isOK) {
+                _context2.next = 19;
+                break;
+              }
+
+              if (!request.responseText) {
+                _context2.next = 10;
+                break;
+              }
+
+              _context2.next = 7;
+              return JSON.parse(request.responseText);
+
+            case 7:
+              _context2.t0 = _context2.sent;
+              _context2.next = 11;
+              break;
+
+            case 10:
+              _context2.t0 = undefined;
+
+            case 11:
+              _context2.t1 = _context2.t0;
+              _context2.t2 = isOK;
+              _context2.t3 = request;
+              _context2.t4 = request.status;
+              _response = {
+                data: _context2.t1,
+                isOK: _context2.t2,
+                request: _context2.t3,
+                status: _context2.t4
+              };
+              resolve(_response);
+              _context2.next = 20;
+              break;
+
+            case 19:
+              if (onIntercept) {
+                interceptedResult = onIntercept({
+                  currentParams: args,
+                  request: request,
+                  status: request.status
+                });
+
+                if (interceptedResult) {
+                  resolve(requestToApi(_extends({}, interceptedResult, {
+                    onIntercept: undefined
+                  })));
+                } else handleError(request, request, reject);
+              } else handleError(request, request, reject);
+
+            case 20:
+            case "end":
               return _context2.stop();
           }
         }
-      }, _callee2, _this);
+      }, _callee2);
     }));
 
-    return function returnData(_x4, _x5, _x6) {
+    return function returnData(_x4, _x5, _x6, _x7) {
       return _ref2.apply(this, arguments);
     };
   }();
 
   var setHeaders = function setHeaders(request) {
-    Object.entries(defaultHeaders).map(function (defaultHeader) {
-      return request.setRequestHeader(defaultHeader[0], String(defaultHeader[1]));
-    });
+    if (!disableDefaultHeaders) {
+      Object.entries(defaultHeaders).map(function (defaultHeader) {
+        return request.setRequestHeader(defaultHeader[0], String(defaultHeader[1]));
+      });
+    }
+
     if (headers && Object.keys(headers).length > 0) {
       Object.entries(headers).map(function (header) {
         return request.setRequestHeader(header[0], String(header[1]));
@@ -1938,8 +969,7 @@ var requestToApi = function requestToApi(args) {
   };
 
   if (method === 'FORM_DATA' && Object.entries(body).length > 0) {
-    Object.entries(body).map(
-    // $FlowFixMe
+    Object.entries(body).map( // $FlowFixMe
     function (entry) {
       return formData.append(entry[0], entry[1]);
     });
@@ -1947,7 +977,7 @@ var requestToApi = function requestToApi(args) {
 
   if (params && Object.keys(params).length > 0) {
     Object.entries(params).map(function (param, index) {
-      return index === 0 ? route = route + '?' + param[0] + '=' + JSON.stringify(param[1]) : route = route + '&' + param[0] + '=' + JSON.stringify(param[1]);
+      return index === 0 ? route = route + "?" + param[0] + "=" + JSON.stringify(param[1]) : route = route + "&" + param[0] + "=" + JSON.stringify(param[1]);
     });
   }
 
@@ -1955,14 +985,18 @@ var requestToApi = function requestToApi(args) {
     return new Promise(function (resolve, reject) {
       try {
         var request = new XMLHttpRequest();
+
         if (request.upload) {
           request.upload.onerror = function (error) {
             return handleError(error, request, resolve);
           };
+
           request.upload.onload = function () {
             return returnData(request, resolve, reject);
           };
+
           request.upload.onprogress = onProgress;
+
           request.upload.ontimeout = function () {
             return handleTimeout(request, reject);
           };
@@ -1971,10 +1005,13 @@ var requestToApi = function requestToApi(args) {
         request.onerror = function (error) {
           return handleError(error, request, resolve);
         };
+
         request.onprogress = onProgress;
+
         request.onreadystatechange = function () {
           return returnData(request, resolve, reject);
         };
+
         request.ontimeout = function () {
           return handleTimeout(request, reject);
         };
@@ -1982,7 +1019,9 @@ var requestToApi = function requestToApi(args) {
         request.open(method === 'FORM_DATA' ? 'POST' : method, route);
         request.timeout = timeout;
         setHeaders(request);
-        request.send(method === 'FORM_DATA' ? formData : method === 'DELETE' || method === 'GET' || method === 'HEAD' || method === 'PUT' ? null : JSON.stringify(_extends({}, body)));
+        if (cancel) returnData(request, resolve, reject, true);
+        request.send(method === 'FORM_DATA' ? formData : method === 'DELETE' || method === 'HEAD' ? null : JSON.stringify(_extends({}, body)));
+        if (cancel) request.abort();
       } catch (request) {
         handleError(request, request, reject);
       }
@@ -1992,400 +1031,4 @@ var requestToApi = function requestToApi(args) {
   return sendRequest();
 };
 
-var isEmptyChildren = function isEmptyChildren(children) {
-  return Children.count(children) === 0;
-};
-
-var Fetch = function (_Component) {
-  inherits(Fetch, _Component);
-
-  function Fetch() {
-    var _this2 = this;
-
-    var _temp, _this, _ret;
-
-    classCallCheck(this, Fetch);
-
-    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
-      args[_key] = arguments[_key];
-    }
-
-    return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this._data = undefined, _this._didCallOnLoad = false, _this._isLoaded = false, _this._isUnmounted = false, _this._fetchData = function () {
-      var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(props, context) {
-        var body, headers, method, onIntercept, onProgress, onTimeout, params, path, url, timeout, route, timeoutValue, apiResponse;
-        return regenerator.wrap(function _callee$(_context) {
-          while (1) {
-            switch (_context.prev = _context.next) {
-              case 0:
-                body = props.body, headers = props.headers, method = props.method, onIntercept = props.onIntercept, onProgress = props.onProgress, onTimeout = props.onTimeout, params = props.params, path = props.path, url = props.url, timeout = props.timeout;
-                route = void 0;
-                timeoutValue = 0;
-
-
-                if (path) route = '' + (context.rdfApi || '') + path;else route = url;
-
-                if (context.rdfTimeout && timeout === -1) timeoutValue = context.rdfTimeout;else if (!context.rdfTimeout && timeout) timeoutValue = Math.max(0, timeout);else if (context.rdfTimeout && timeout) timeoutValue = timeout === -1 ? context.rdfTimeout : timeout;
-
-                _context.prev = 5;
-                _context.next = 8;
-                return requestToApi({
-                  url: route || '',
-                  body: _extends({}, body),
-                  headers: _extends({}, context.rdfHeaders, headers),
-                  method: method,
-                  onTimeout: onTimeout,
-                  onProgress: onProgress,
-                  onIntercept: onIntercept || context.rdfInterceptor,
-                  params: _extends({}, params),
-                  timeout: timeoutValue
-                });
-
-              case 8:
-                apiResponse = _context.sent;
-
-                if (!_this._isUnmounted) {
-                  _this._handleData(_extends({}, apiResponse, {
-                    store: context.rdfStore
-                  }));
-                }
-                _context.next = 15;
-                break;
-
-              case 12:
-                _context.prev = 12;
-                _context.t0 = _context['catch'](5);
-
-                if (!_this._isUnmounted) {
-                  _this._handleData({
-                    error: {
-                      content: _context.t0,
-                      message: 'Something went wrong during the request',
-                      url: route
-                    },
-                    isOK: false,
-                    store: context.rdfStore
-                  });
-                  if (process.env.NODE_ENV !== 'production') {
-                    !!_context.t0 ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<Fetch /> tried to call the route "' + String(route) + '" ' + ('with "' + String(method).toUpperCase() + '" method ') + 'but resolved with the following error: %s\n', _this._printError(_context.t0)) : invariant_1(false) : void 0;
-                  }
-                }
-
-              case 15:
-              case 'end':
-                return _context.stop();
-            }
-          }
-        }, _callee, _this2, [[5, 12]]);
-      }));
-
-      return function (_x, _x2) {
-        return _ref.apply(this, arguments);
-      };
-    }(), _this._handleData = function (result) {
-      if (!_this._isUnmounted) {
-        _this._isLoaded = true;
-        _this.props.resultOnly ? _this._data = result.error || result.data : _this._data = result;
-        _this._returnData(result);
-      }
-    }, _this._printError = function (error) {
-      return error.response && JSON.stringify(error.response).length ? typeof error.response === 'string' ? error.response : _typeof(error.response) === 'object' ? JSON.stringify(error.response, null, 2) : error.response + '. Sorry <Fetch /> couldn\'t turned this into a readable string. ' + 'Check error.content.request to see what happened.' : " .Sorry <Fetch /> couldn't turned this into a readable string. " + 'Check error.content.request to see what happened.';
-    }, _this._renderLoader = function () {
-      var rdfLoader = _this.context.rdfLoader;
-      var loader = _this.props.loader;
-
-
-      if (rdfLoader && !loader) return typeof rdfLoader === 'function' ? rdfLoader() : rdfLoader;
-      if (!rdfLoader && loader) return typeof loader === 'function' ? loader() : loader;
-      if (rdfLoader && loader) return typeof loader === 'function' ? loader() : loader;
-
-      return null;
-    }, _this._returnData = function (result) {
-      var _this$props = _this.props,
-          onError = _this$props.onError,
-          onFetch = _this$props.onFetch;
-
-
-      if (onFetch) onFetch(_this._data);
-
-      if (result.error && onError) onError(_this._data);
-
-      if (!_this._isUnmounted) _this.forceUpdate();
-    }, _this._validateProps = function (props, context) {
-      var rdfApi = context.rdfApi,
-          rdfStore = context.rdfStore,
-          rdfTimeout = context.rdfTimeout;
-      var children = props.children,
-          component = props.component,
-          onTimeout = props.onTimeout,
-          onFetch = props.onFetch,
-          path = props.path,
-          refetch = props.refetch,
-          render = props.render,
-          timeout = props.timeout,
-          url = props.url;
-
-
-      !(path || url) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must provide a `url` or a `path` to <Fetch />') : invariant_1(false) : void 0;
-
-      if (path) {
-        !(path && rdfApi) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must implement <FetchProvider> at the root of your ' + 'app and provide an `api` in order to use `path`') : invariant_1(false) : void 0;
-      }
-
-      if (path === 'store') {
-        !(path && rdfStore) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must implement <FetchProvider> at the root of your ' + 'app and provide a `store` in order to use `path="store"`') : invariant_1(false) : void 0;
-      }
-
-      if (onTimeout) {
-        !(typeof timeout === 'number' && timeout >= 0 || typeof rdfTimeout === 'number' && rdfTimeout >= 0) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must provide a `timeout` number in ms to <Fetch /> or ' + '<FetchProvider> in order to use `onTimeout`') : invariant_1(false) : void 0;
-      }
-
-      !(children || component || render || onFetch) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must provide at least one of the following ' + 'to <Fetch />: children, `component`, `onFetch`, `render`') : invariant_1(false) : void 0;
-
-      if (typeof refetch !== 'undefined') {
-        var message = '`refetch` is deprecated and will be removed ' + 'in the next major version. ' + 'Please use `refetchKey` instead.';
-
-        if (process.env.NODE_ENV !== 'production') {
-          if (typeof console !== 'undefined') console.error(message);
-
-          try {
-            throw new Error(message);
-          } catch (x) {} // eslint-disable-line
-        }
-      }
-    }, _temp), possibleConstructorReturn(_this, _ret);
-  }
-
-  Fetch.prototype.componentWillMount = function componentWillMount() {
-    this._validateProps(this.props, this.context);
-    if (this.props.onLoad && !this._didCallOnLoad) {
-      this._didCallOnLoad = true;
-      this.props.onLoad();
-    }
-  };
-
-  Fetch.prototype.componentDidMount = function componentDidMount() {
-    if (this.props.path === 'store') {
-      this._handleData({
-        data: this.context.rdfStore,
-        isOK: true
-      });
-    } else this._fetchData(this.props, this.context);
-  };
-
-  Fetch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
-    var _props = this.props,
-        onLoad = _props.onLoad,
-        path = _props.path,
-        refetch = _props.refetch,
-        refetchKey = _props.refetchKey;
-
-
-    this._validateProps(nextProps, nextContext);
-
-    if (onLoad && !this._didCallOnLoad) {
-      this._didCallOnLoad = true;
-      onLoad();
-    }
-
-    if (path === 'store') {
-      this._handleData({
-        data: this.context.rdfStore,
-        isOK: true
-      });
-    } else if (nextProps.path !== path || nextProps.refetch !== refetch || nextProps.refetchKey !== refetchKey) {
-      this._isLoaded = false;
-      this._fetchData(nextProps, nextContext);
-    }
-  };
-
-  Fetch.prototype.componentWillUnmount = function componentWillUnmount() {
-    this._isUnmounted = true;
-  };
-
-  Fetch.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
-    if (this.props.children !== nextProps.children) return true;
-    if (this.props.loader !== nextProps.loader) return true;
-    if (this.props.onError !== nextProps.onError) return true;
-    if (this.props.onFetch !== nextProps.onFetch) return true;
-    if (this.props.onLoad !== nextProps.onLoad) return true;
-    if (this.props.path !== nextProps.path) return true;
-    if (this.props.params !== nextProps.params) return true;
-    if (this.props.refetch !== nextProps.refetch) return true;
-    if (this.props.refetchKey !== nextProps.refetchKey) return true;
-    if (this.props.render !== nextProps.render) return true;
-    if (this._isLoaded) return true;
-    if (this._data) return true;
-    return false;
-  };
-
-  Fetch.prototype.render = function render() {
-    var _props2 = this.props,
-        children = _props2.children,
-        component = _props2.component,
-        render = _props2.render;
-
-
-    if (!this._isLoaded && !this._isUnmounted) return this._renderLoader();
-
-    if (this._isLoaded && !this._isUnmounted) {
-      if (component) return createElement(component, this._data);
-
-      if (typeof render === 'function') return render(this._data);
-
-      if (typeof children === 'function') return children(this._data);
-
-      if (children && !isEmptyChildren(children)) return Children.only(children);
-    }
-
-    return null;
-  };
-
-  return Fetch;
-}(Component);
-
-Fetch.propTypes = {
-  body: propTypes.object,
-  children: propTypes.oneOfType([propTypes.element, propTypes.func]),
-  component: propTypes.oneOfType([propTypes.element, propTypes.func]),
-  method: methodShape,
-  loader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-  onError: propTypes.func,
-  onFetch: propTypes.func,
-  onLoad: propTypes.func,
-  onProgress: propTypes.func,
-  onTimeout: propTypes.func,
-  params: propTypes.object,
-  path: propTypes.string,
-  refetch: propTypes.any,
-  refetchKey: propTypes.any,
-  render: propTypes.func,
-  resultOnly: propTypes.bool,
-  url: propTypes.string,
-  timeout: propTypes.number
-};
-Fetch.contextTypes = {
-  rdfApi: propTypes.string,
-  rdfHeaders: propTypes.object,
-  rdfInterceptor: propTypes.func,
-  rdfLoader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-  rdfStore: propTypes.object,
-  rdfTimeout: propTypes.number
-};
-Fetch.defaultProps = {
-  body: {},
-  children: undefined,
-  component: undefined,
-  loader: undefined,
-  method: 'GET',
-  onError: undefined,
-  onFetch: undefined,
-  onLoad: undefined,
-  onProgress: undefined,
-  onTimeout: undefined,
-  params: {},
-  path: undefined,
-  refetch: undefined,
-  refetchKey: undefined,
-  render: undefined,
-  resultOnly: false,
-  url: undefined,
-  timeout: -1
-};
-
-var _this2$1 = undefined;
-
-var createFetchProvider = function createFetchProvider() {
-  var FetchProvider = function (_Component) {
-    inherits(FetchProvider, _Component);
-
-    function FetchProvider() {
-      var _temp, _this, _ret;
-
-      classCallCheck(this, FetchProvider);
-
-      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
-        args[_key] = arguments[_key];
-      }
-
-      return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.rdfApi = _this.props.api, _this.rdfHeaders = _this.props.headers, _this.rdfInterceptor = _this.props.onIntercept, _this.rdfLoader = _this.props.loader, _this.rdfStore = _this.context && _this.context.store ? _this.context.store.getState() : _this.props.store, _this.rdfTimeout = _this.props.timeout, _this.componentWillReceiveProps = function () {
-        return null;
-      }, _temp), possibleConstructorReturn(_this, _ret);
-    }
-
-    FetchProvider.prototype.getChildContext = function getChildContext() {
-      return {
-        rdfApi: this.rdfApi || '',
-        rdfHeaders: this.rdfHeaders,
-        rdfInterceptor: this.rdfInterceptor,
-        rdfLoader: this.rdfLoader,
-        rdfStore: this.props.store || this.rdfStore,
-        rdfTimeout: this.rdfTimeout
-      };
-    };
-
-    FetchProvider.prototype.render = function render() {
-      return Children.only(this.props.children);
-    };
-
-    return FetchProvider;
-  }(Component);
-
-  FetchProvider.defaultProps = {
-    api: undefined,
-    headers: {},
-    loader: undefined,
-    onIntercept: undefined,
-    store: undefined,
-    timeout: undefined
-  };
-  FetchProvider.propTypes = {
-    api: propTypes.string,
-    children: propTypes.element.isRequired,
-    headers: propTypes.object,
-    loader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-    onIntercept: propTypes.func,
-    store: storeShape,
-    timeout: propTypes.number
-  };
-  FetchProvider.contextTypes = {
-    store: storeShape
-  };
-  FetchProvider.childContextTypes = {
-    rdfApi: propTypes.string,
-    rdfHeaders: propTypes.object,
-    rdfInterceptor: propTypes.func,
-    rdfLoader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-    rdfStore: propTypes.object,
-    rdfTimeout: propTypes.number
-  };
-
-
-  if (process.env.NODE_ENV !== 'production') {
-    FetchProvider.prototype.componentWillReceiveProps = function (nextProps) {
-      !(
-      // $FlowFixMe
-      _this2$1.rdfApi === nextProps.api) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `api` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2$1.rdfHeaders === nextProps.headers) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `headers` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2$1.rdfLoader === nextProps.loader) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `loader` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2$1.rdfInterceptor === nextProps.onIntercept) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `onIntercept` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2$1.rdfStore === nextProps.store) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `store` on the fly.') : invariant_1(false) : void 0;
-      !(
-      // $FlowFixMe
-      _this2$1.rdfTimeout === nextProps.timeout) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `timeout` on the fly.') : invariant_1(false) : void 0;
-    };
-  }
-
-  return FetchProvider;
-};
-
-var FetchProvider = createFetchProvider();
-
-export { ConnectedFetch, Fetch, FetchProvider, requestToApi };
+export default requestToApi;
diff --git a/node_modules/react-data-fetching/umd/react-data-fetching.js b/node_modules/react-data-fetching/umd/react-data-fetching.js
index de11d46..47b824b 100644
--- a/node_modules/react-data-fetching/umd/react-data-fetching.js
+++ b/node_modules/react-data-fetching/umd/react-data-fetching.js
@@ -1,999 +1,68 @@
 (function (global, factory) {
-	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('react')) :
-	typeof define === 'function' && define.amd ? define(['exports', 'react'], factory) :
-	(factory((global.ReactDataFetching = {}),global.React));
-}(this, (function (exports,react) { 'use strict';
+	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
+	typeof define === 'function' && define.amd ? define(factory) :
+	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ReactDataFetching = factory());
+  }(this, (function () { 'use strict';
   
-	function createCommonjsModule(fn, module) {
-		return module = { exports: {} }, fn(module, module.exports), module.exports;
-	}
-
-	/*
-	object-assign
-	(c) Sindre Sorhus
-	@license MIT
-	*/
-	/* eslint-disable no-unused-vars */
-	var getOwnPropertySymbols = Object.getOwnPropertySymbols;
-	var hasOwnProperty = Object.prototype.hasOwnProperty;
-	var propIsEnumerable = Object.prototype.propertyIsEnumerable;
-
-	function toObject(val) {
-		if (val === null || val === undefined) {
-			throw new TypeError('Object.assign cannot be called with null or undefined');
-		}
+	function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
+	  try {
+		var info = gen[key](arg);
+		var value = info.value;
+	  } catch (error) {
+		reject(error);
+		return;
+	  }
   
-		return Object(val);
+	  if (info.done) {
+		resolve(value);
+	  } else {
+		Promise.resolve(value).then(_next, _throw);
+	  }
 	}
   
-	function shouldUseNative() {
-		try {
-			if (!Object.assign) {
-				return false;
-			}
-
-			// Detect buggy property enumeration order in older V8 versions.
+	function _asyncToGenerator(fn) {
+	  return function () {
+		var self = this,
+			args = arguments;
+		return new Promise(function (resolve, reject) {
+		  var gen = fn.apply(self, args);
   
-			// https://bugs.chromium.org/p/v8/issues/detail?id=4118
-			var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
-			test1[5] = 'de';
-			if (Object.getOwnPropertyNames(test1)[0] === '5') {
-				return false;
-			}
+		  function _next(value) {
+			asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
+		  }
   
-			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
-			var test2 = {};
-			for (var i = 0; i < 10; i++) {
-				test2['_' + String.fromCharCode(i)] = i;
-			}
-			var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
-				return test2[n];
-			});
-			if (order2.join('') !== '0123456789') {
-				return false;
-			}
-
-			// https://bugs.chromium.org/p/v8/issues/detail?id=3056
-			var test3 = {};
-			'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
-				test3[letter] = letter;
-			});
-			if (Object.keys(Object.assign({}, test3)).join('') !==
-					'abcdefghijklmnopqrst') {
-				return false;
-			}
+		  function _throw(err) {
+			asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
+		  }
   
-			return true;
-		} catch (err) {
-			// We don't expect any of the above to throw, but better to be safe.
-			return false;
-		}
+		  _next(undefined);
+		});
+	  };
 	}
   
-	var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
-		var from;
-		var to = toObject(target);
-		var symbols;
-
-		for (var s = 1; s < arguments.length; s++) {
-			from = Object(arguments[s]);
+	function _extends() {
+	  _extends = Object.assign || function (target) {
+		for (var i = 1; i < arguments.length; i++) {
+		  var source = arguments[i];
   
-			for (var key in from) {
-				if (hasOwnProperty.call(from, key)) {
-					to[key] = from[key];
-				}
-			}
-
-			if (getOwnPropertySymbols) {
-				symbols = getOwnPropertySymbols(from);
-				for (var i = 0; i < symbols.length; i++) {
-					if (propIsEnumerable.call(from, symbols[i])) {
-						to[symbols[i]] = from[symbols[i]];
-					}
-				}
+		  for (var key in source) {
+			if (Object.prototype.hasOwnProperty.call(source, key)) {
+			  target[key] = source[key];
 			}
+		  }
 		}
   
-		return to;
-	};
-
-	/**
-	 * Copyright (c) 2013-present, Facebook, Inc.
-	 *
-	 * This source code is licensed under the MIT license found in the
-	 * LICENSE file in the root directory of this source tree.
-	 */
-
-	var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
-
-	var ReactPropTypesSecret_1 = ReactPropTypesSecret;
-
-	var printWarning = function() {};
-
-	{
-	  var ReactPropTypesSecret$1 = ReactPropTypesSecret_1;
-	  var loggedTypeFailures = {};
-
-	  printWarning = function(text) {
-	    var message = 'Warning: ' + text;
-	    if (typeof console !== 'undefined') {
-	      console.error(message);
-	    }
-	    try {
-	      // --- Welcome to debugging React ---
-	      // This error was thrown as a convenience so that you can use this stack
-	      // to find the callsite that caused this warning to fire.
-	      throw new Error(message);
-	    } catch (x) {}
-	  };
-	}
-
-	/**
-	 * Assert that the values match with the type specs.
-	 * Error messages are memorized and will only be shown once.
-	 *
-	 * @param {object} typeSpecs Map of name to a ReactPropType
-	 * @param {object} values Runtime values that need to be type-checked
-	 * @param {string} location e.g. "prop", "context", "child context"
-	 * @param {string} componentName Name of the component for error messages.
-	 * @param {?Function} getStack Returns the component stack.
-	 * @private
-	 */
-	function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
-	  {
-	    for (var typeSpecName in typeSpecs) {
-	      if (typeSpecs.hasOwnProperty(typeSpecName)) {
-	        var error;
-	        // Prop type validation may throw. In case they do, we don't want to
-	        // fail the render phase where it didn't fail before. So we log it.
-	        // After these have been cleaned up, we'll let them throw.
-	        try {
-	          // This is intentionally an invariant that gets caught. It's the same
-	          // behavior as without this statement except with a better message.
-	          if (typeof typeSpecs[typeSpecName] !== 'function') {
-	            var err = Error(
-	              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
-	              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
-	            );
-	            err.name = 'Invariant Violation';
-	            throw err;
-	          }
-	          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret$1);
-	        } catch (ex) {
-	          error = ex;
-	        }
-	        if (error && !(error instanceof Error)) {
-	          printWarning(
-	            (componentName || 'React class') + ': type specification of ' +
-	            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
-	            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
-	            'You may have forgotten to pass an argument to the type checker ' +
-	            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
-	            'shape all require an argument).'
-	          );
-
-	        }
-	        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
-	          // Only monitor this failure once because there tends to be a lot of the
-	          // same error.
-	          loggedTypeFailures[error.message] = true;
-
-	          var stack = getStack ? getStack() : '';
-
-	          printWarning(
-	            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
-	          );
-	        }
-	      }
-	    }
-	  }
-	}
-
-	var checkPropTypes_1 = checkPropTypes;
-
-	var printWarning$1 = function() {};
-
-	{
-	  printWarning$1 = function(text) {
-	    var message = 'Warning: ' + text;
-	    if (typeof console !== 'undefined') {
-	      console.error(message);
-	    }
-	    try {
-	      // --- Welcome to debugging React ---
-	      // This error was thrown as a convenience so that you can use this stack
-	      // to find the callsite that caused this warning to fire.
-	      throw new Error(message);
-	    } catch (x) {}
+		return target;
 	  };
-	}
   
-	function emptyFunctionThatReturnsNull() {
-	  return null;
+	  return _extends.apply(this, arguments);
 	}
   
-	var factoryWithTypeCheckers = function(isValidElement, throwOnDirectAccess) {
-	  /* global Symbol */
-	  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
-	  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
-
-	  /**
-	   * Returns the iterator method function contained on the iterable object.
-	   *
-	   * Be sure to invoke the function with the iterable as context:
-	   *
-	   *     var iteratorFn = getIteratorFn(myIterable);
-	   *     if (iteratorFn) {
-	   *       var iterator = iteratorFn.call(myIterable);
-	   *       ...
-	   *     }
-	   *
-	   * @param {?object} maybeIterable
-	   * @return {?function}
-	   */
-	  function getIteratorFn(maybeIterable) {
-	    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
-	    if (typeof iteratorFn === 'function') {
-	      return iteratorFn;
-	    }
-	  }
-
-	  /**
-	   * Collection of methods that allow declaration and validation of props that are
-	   * supplied to React components. Example usage:
-	   *
-	   *   var Props = require('ReactPropTypes');
-	   *   var MyArticle = React.createClass({
-	   *     propTypes: {
-	   *       // An optional string prop named "description".
-	   *       description: Props.string,
-	   *
-	   *       // A required enum prop named "category".
-	   *       category: Props.oneOf(['News','Photos']).isRequired,
-	   *
-	   *       // A prop named "dialog" that requires an instance of Dialog.
-	   *       dialog: Props.instanceOf(Dialog).isRequired
-	   *     },
-	   *     render: function() { ... }
-	   *   });
-	   *
-	   * A more formal specification of how these methods are used:
-	   *
-	   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
-	   *   decl := ReactPropTypes.{type}(.isRequired)?
-	   *
-	   * Each and every declaration produces a function with the same signature. This
-	   * allows the creation of custom validation functions. For example:
-	   *
-	   *  var MyLink = React.createClass({
-	   *    propTypes: {
-	   *      // An optional string or URI prop named "href".
-	   *      href: function(props, propName, componentName) {
-	   *        var propValue = props[propName];
-	   *        if (propValue != null && typeof propValue !== 'string' &&
-	   *            !(propValue instanceof URI)) {
-	   *          return new Error(
-	   *            'Expected a string or an URI for ' + propName + ' in ' +
-	   *            componentName
-	   *          );
-	   *        }
-	   *      }
-	   *    },
-	   *    render: function() {...}
-	   *  });
-	   *
-	   * @internal
-	   */
-
-	  var ANONYMOUS = '<<anonymous>>';
-
-	  // Important!
-	  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
-	  var ReactPropTypes = {
-	    array: createPrimitiveTypeChecker('array'),
-	    bool: createPrimitiveTypeChecker('boolean'),
-	    func: createPrimitiveTypeChecker('function'),
-	    number: createPrimitiveTypeChecker('number'),
-	    object: createPrimitiveTypeChecker('object'),
-	    string: createPrimitiveTypeChecker('string'),
-	    symbol: createPrimitiveTypeChecker('symbol'),
-
-	    any: createAnyTypeChecker(),
-	    arrayOf: createArrayOfTypeChecker,
-	    element: createElementTypeChecker(),
-	    instanceOf: createInstanceTypeChecker,
-	    node: createNodeChecker(),
-	    objectOf: createObjectOfTypeChecker,
-	    oneOf: createEnumTypeChecker,
-	    oneOfType: createUnionTypeChecker,
-	    shape: createShapeTypeChecker,
-	    exact: createStrictShapeTypeChecker,
-	  };
-
-	  /**
-	   * inlined Object.is polyfill to avoid requiring consumers ship their own
-	   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
-	   */
-	  /*eslint-disable no-self-compare*/
-	  function is(x, y) {
-	    // SameValue algorithm
-	    if (x === y) {
-	      // Steps 1-5, 7-10
-	      // Steps 6.b-6.e: +0 != -0
-	      return x !== 0 || 1 / x === 1 / y;
-	    } else {
-	      // Step 6.a: NaN == NaN
-	      return x !== x && y !== y;
-	    }
-	  }
-	  /*eslint-enable no-self-compare*/
-
-	  /**
-	   * We use an Error-like object for backward compatibility as people may call
-	   * PropTypes directly and inspect their output. However, we don't use real
-	   * Errors anymore. We don't inspect their stack anyway, and creating them
-	   * is prohibitively expensive if they are created too often, such as what
-	   * happens in oneOfType() for any type before the one that matched.
-	   */
-	  function PropTypeError(message) {
-	    this.message = message;
-	    this.stack = '';
-	  }
-	  // Make `instanceof Error` still work for returned errors.
-	  PropTypeError.prototype = Error.prototype;
-
-	  function createChainableTypeChecker(validate) {
-	    {
-	      var manualPropTypeCallCache = {};
-	      var manualPropTypeWarningCount = 0;
-	    }
-	    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
-	      componentName = componentName || ANONYMOUS;
-	      propFullName = propFullName || propName;
-
-	      if (secret !== ReactPropTypesSecret_1) {
-	        if (throwOnDirectAccess) {
-	          // New behavior only for users of `prop-types` package
-	          var err = new Error(
-	            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
-	            'Use `PropTypes.checkPropTypes()` to call them. ' +
-	            'Read more at http://fb.me/use-check-prop-types'
-	          );
-	          err.name = 'Invariant Violation';
-	          throw err;
-	        } else if (typeof console !== 'undefined') {
-	          // Old behavior for people using React.PropTypes
-	          var cacheKey = componentName + ':' + propName;
-	          if (
-	            !manualPropTypeCallCache[cacheKey] &&
-	            // Avoid spamming the console because they are often not actionable except for lib authors
-	            manualPropTypeWarningCount < 3
-	          ) {
-	            printWarning$1(
-	              'You are manually calling a React.PropTypes validation ' +
-	              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
-	              'and will throw in the standalone `prop-types` package. ' +
-	              'You may be seeing this warning due to a third-party PropTypes ' +
-	              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
-	            );
-	            manualPropTypeCallCache[cacheKey] = true;
-	            manualPropTypeWarningCount++;
-	          }
-	        }
-	      }
-	      if (props[propName] == null) {
-	        if (isRequired) {
-	          if (props[propName] === null) {
-	            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
-	          }
-	          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
-	        }
-	        return null;
-	      } else {
-	        return validate(props, propName, componentName, location, propFullName);
-	      }
-	    }
-
-	    var chainedCheckType = checkType.bind(null, false);
-	    chainedCheckType.isRequired = checkType.bind(null, true);
-
-	    return chainedCheckType;
-	  }
-
-	  function createPrimitiveTypeChecker(expectedType) {
-	    function validate(props, propName, componentName, location, propFullName, secret) {
-	      var propValue = props[propName];
-	      var propType = getPropType(propValue);
-	      if (propType !== expectedType) {
-	        // `propValue` being instance of, say, date/regexp, pass the 'object'
-	        // check, but we can offer a more precise error message here rather than
-	        // 'of type `object`'.
-	        var preciseType = getPreciseType(propValue);
-
-	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
-	      }
-	      return null;
-	    }
-	    return createChainableTypeChecker(validate);
-	  }
-
-	  function createAnyTypeChecker() {
-	    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
-	  }
-
-	  function createArrayOfTypeChecker(typeChecker) {
-	    function validate(props, propName, componentName, location, propFullName) {
-	      if (typeof typeChecker !== 'function') {
-	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
-	      }
-	      var propValue = props[propName];
-	      if (!Array.isArray(propValue)) {
-	        var propType = getPropType(propValue);
-	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
-	      }
-	      for (var i = 0; i < propValue.length; i++) {
-	        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret_1);
-	        if (error instanceof Error) {
-	          return error;
-	        }
-	      }
-	      return null;
-	    }
-	    return createChainableTypeChecker(validate);
-	  }
-
-	  function createElementTypeChecker() {
-	    function validate(props, propName, componentName, location, propFullName) {
-	      var propValue = props[propName];
-	      if (!isValidElement(propValue)) {
-	        var propType = getPropType(propValue);
-	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
-	      }
-	      return null;
-	    }
-	    return createChainableTypeChecker(validate);
-	  }
-
-	  function createInstanceTypeChecker(expectedClass) {
-	    function validate(props, propName, componentName, location, propFullName) {
-	      if (!(props[propName] instanceof expectedClass)) {
-	        var expectedClassName = expectedClass.name || ANONYMOUS;
-	        var actualClassName = getClassName(props[propName]);
-	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
-	      }
-	      return null;
-	    }
-	    return createChainableTypeChecker(validate);
-	  }
-
-	  function createEnumTypeChecker(expectedValues) {
-	    if (!Array.isArray(expectedValues)) {
-	      printWarning$1('Invalid argument supplied to oneOf, expected an instance of array.');
-	      return emptyFunctionThatReturnsNull;
-	    }
-
-	    function validate(props, propName, componentName, location, propFullName) {
-	      var propValue = props[propName];
-	      for (var i = 0; i < expectedValues.length; i++) {
-	        if (is(propValue, expectedValues[i])) {
-	          return null;
-	        }
-	      }
-
-	      var valuesString = JSON.stringify(expectedValues);
-	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
-	    }
-	    return createChainableTypeChecker(validate);
-	  }
-
-	  function createObjectOfTypeChecker(typeChecker) {
-	    function validate(props, propName, componentName, location, propFullName) {
-	      if (typeof typeChecker !== 'function') {
-	        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
-	      }
-	      var propValue = props[propName];
-	      var propType = getPropType(propValue);
-	      if (propType !== 'object') {
-	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
-	      }
-	      for (var key in propValue) {
-	        if (propValue.hasOwnProperty(key)) {
-	          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
-	          if (error instanceof Error) {
-	            return error;
-	          }
-	        }
-	      }
-	      return null;
-	    }
-	    return createChainableTypeChecker(validate);
-	  }
-
-	  function createUnionTypeChecker(arrayOfTypeCheckers) {
-	    if (!Array.isArray(arrayOfTypeCheckers)) {
-	      printWarning$1('Invalid argument supplied to oneOfType, expected an instance of array.');
-	      return emptyFunctionThatReturnsNull;
-	    }
-
-	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
-	      var checker = arrayOfTypeCheckers[i];
-	      if (typeof checker !== 'function') {
-	        printWarning$1(
-	          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
-	          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
-	        );
-	        return emptyFunctionThatReturnsNull;
-	      }
-	    }
-
-	    function validate(props, propName, componentName, location, propFullName) {
-	      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
-	        var checker = arrayOfTypeCheckers[i];
-	        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret_1) == null) {
-	          return null;
-	        }
-	      }
-
-	      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
-	    }
-	    return createChainableTypeChecker(validate);
-	  }
-
-	  function createNodeChecker() {
-	    function validate(props, propName, componentName, location, propFullName) {
-	      if (!isNode(props[propName])) {
-	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
-	      }
-	      return null;
-	    }
-	    return createChainableTypeChecker(validate);
-	  }
-
-	  function createShapeTypeChecker(shapeTypes) {
-	    function validate(props, propName, componentName, location, propFullName) {
-	      var propValue = props[propName];
-	      var propType = getPropType(propValue);
-	      if (propType !== 'object') {
-	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
-	      }
-	      for (var key in shapeTypes) {
-	        var checker = shapeTypes[key];
-	        if (!checker) {
-	          continue;
-	        }
-	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
-	        if (error) {
-	          return error;
-	        }
-	      }
-	      return null;
-	    }
-	    return createChainableTypeChecker(validate);
-	  }
-
-	  function createStrictShapeTypeChecker(shapeTypes) {
-	    function validate(props, propName, componentName, location, propFullName) {
-	      var propValue = props[propName];
-	      var propType = getPropType(propValue);
-	      if (propType !== 'object') {
-	        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
-	      }
-	      // We need to check all keys in case some are required but missing from
-	      // props.
-	      var allKeys = objectAssign({}, props[propName], shapeTypes);
-	      for (var key in allKeys) {
-	        var checker = shapeTypes[key];
-	        if (!checker) {
-	          return new PropTypeError(
-	            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
-	            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
-	            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
-	          );
-	        }
-	        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret_1);
-	        if (error) {
-	          return error;
-	        }
-	      }
-	      return null;
-	    }
-
-	    return createChainableTypeChecker(validate);
-	  }
-
-	  function isNode(propValue) {
-	    switch (typeof propValue) {
-	      case 'number':
-	      case 'string':
-	      case 'undefined':
-	        return true;
-	      case 'boolean':
-	        return !propValue;
-	      case 'object':
-	        if (Array.isArray(propValue)) {
-	          return propValue.every(isNode);
-	        }
-	        if (propValue === null || isValidElement(propValue)) {
-	          return true;
-	        }
-
-	        var iteratorFn = getIteratorFn(propValue);
-	        if (iteratorFn) {
-	          var iterator = iteratorFn.call(propValue);
-	          var step;
-	          if (iteratorFn !== propValue.entries) {
-	            while (!(step = iterator.next()).done) {
-	              if (!isNode(step.value)) {
-	                return false;
-	              }
-	            }
-	          } else {
-	            // Iterator will provide entry [k,v] tuples rather than values.
-	            while (!(step = iterator.next()).done) {
-	              var entry = step.value;
-	              if (entry) {
-	                if (!isNode(entry[1])) {
-	                  return false;
-	                }
-	              }
-	            }
-	          }
-	        } else {
-	          return false;
-	        }
-
-	        return true;
-	      default:
-	        return false;
-	    }
-	  }
-
-	  function isSymbol(propType, propValue) {
-	    // Native Symbol.
-	    if (propType === 'symbol') {
-	      return true;
-	    }
-
-	    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
-	    if (propValue['@@toStringTag'] === 'Symbol') {
-	      return true;
-	    }
-
-	    // Fallback for non-spec compliant Symbols which are polyfilled.
-	    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
-	      return true;
-	    }
-
-	    return false;
-	  }
-
-	  // Equivalent of `typeof` but with special handling for array and regexp.
-	  function getPropType(propValue) {
-	    var propType = typeof propValue;
-	    if (Array.isArray(propValue)) {
-	      return 'array';
-	    }
-	    if (propValue instanceof RegExp) {
-	      // Old webkits (at least until Android 4.0) return 'function' rather than
-	      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
-	      // passes PropTypes.object.
-	      return 'object';
-	    }
-	    if (isSymbol(propType, propValue)) {
-	      return 'symbol';
-	    }
-	    return propType;
-	  }
-
-	  // This handles more types than `getPropType`. Only used for error messages.
-	  // See `createPrimitiveTypeChecker`.
-	  function getPreciseType(propValue) {
-	    if (typeof propValue === 'undefined' || propValue === null) {
-	      return '' + propValue;
-	    }
-	    var propType = getPropType(propValue);
-	    if (propType === 'object') {
-	      if (propValue instanceof Date) {
-	        return 'date';
-	      } else if (propValue instanceof RegExp) {
-	        return 'regexp';
-	      }
-	    }
-	    return propType;
-	  }
-
-	  // Returns a string that is postfixed to a warning about an invalid type.
-	  // For example, "undefined" or "of type array"
-	  function getPostfixForTypeWarning(value) {
-	    var type = getPreciseType(value);
-	    switch (type) {
-	      case 'array':
-	      case 'object':
-	        return 'an ' + type;
-	      case 'boolean':
-	      case 'date':
-	      case 'regexp':
-	        return 'a ' + type;
-	      default:
-	        return type;
-	    }
-	  }
-
-	  // Returns class name of the object, if any.
-	  function getClassName(propValue) {
-	    if (!propValue.constructor || !propValue.constructor.name) {
-	      return ANONYMOUS;
-	    }
-	    return propValue.constructor.name;
-	  }
-
-	  ReactPropTypes.checkPropTypes = checkPropTypes_1;
-	  ReactPropTypes.PropTypes = ReactPropTypes;
-
-	  return ReactPropTypes;
-	};
-
-	var propTypes = createCommonjsModule(function (module) {
-	/**
-	 * Copyright (c) 2013-present, Facebook, Inc.
-	 *
-	 * This source code is licensed under the MIT license found in the
-	 * LICENSE file in the root directory of this source tree.
-	 */
-
-	{
-	  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
-	    Symbol.for &&
-	    Symbol.for('react.element')) ||
-	    0xeac7;
-
-	  var isValidElement = function(object) {
-	    return typeof object === 'object' &&
-	      object !== null &&
-	      object.$$typeof === REACT_ELEMENT_TYPE;
-	  };
-
-	  // By explicitly using `prop-types` you are opting into new development behavior.
-	  // http://fb.me/prop-types-in-prod
-	  var throwOnDirectAccess = true;
-	  module.exports = factoryWithTypeCheckers(isValidElement, throwOnDirectAccess);
+	function createCommonjsModule(fn, module) {
+		return module = { exports: {} }, fn(module, module.exports), module.exports;
 	}
-	});
   
-	/**
-	 * Copyright (c) 2013-present, Facebook, Inc.
-	 *
-	 * This source code is licensed under the MIT license found in the
-	 * LICENSE file in the root directory of this source tree.
-	 */
-
-	var invariant = function(condition, format, a, b, c, d, e, f) {
-	  {
-	    if (format === undefined) {
-	      throw new Error('invariant requires an error message argument');
-	    }
-	  }
-
-	  if (!condition) {
-	    var error;
-	    if (format === undefined) {
-	      error = new Error(
-	        'Minified exception occurred; use the non-minified dev environment ' +
-	        'for the full error message and additional helpful warnings.'
-	      );
-	    } else {
-	      var args = [a, b, c, d, e, f];
-	      var argIndex = 0;
-	      error = new Error(
-	        format.replace(/%s/g, function() { return args[argIndex++]; })
-	      );
-	      error.name = 'Invariant Violation';
-	    }
-
-	    error.framesToPop = 1; // we don't care about invariant's own frame
-	    throw error;
-	  }
-	};
-
-	var invariant_1 = invariant;
-
-	// FLOW
-
-	// PROPTYPES
-	var methodShape = propTypes.oneOf(['DELETE', 'FORM_DATA', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT', 'TRACE']);
-
-	var storeShape = propTypes.shape({
-	  getState: propTypes.func
-	});
-
-	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
-	  return typeof obj;
-	} : function (obj) {
-	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
-	};
-
-	var asyncToGenerator = function (fn) {
-	  return function () {
-	    var gen = fn.apply(this, arguments);
-	    return new Promise(function (resolve, reject) {
-	      function step(key, arg) {
-	        try {
-	          var info = gen[key](arg);
-	          var value = info.value;
-	        } catch (error) {
-	          reject(error);
-	          return;
-	        }
-
-	        if (info.done) {
-	          resolve(value);
-	        } else {
-	          return Promise.resolve(value).then(function (value) {
-	            step("next", value);
-	          }, function (err) {
-	            step("throw", err);
-	          });
-	        }
-	      }
-
-	      return step("next");
-	    });
-	  };
-	};
-
-	var classCallCheck = function (instance, Constructor) {
-	  if (!(instance instanceof Constructor)) {
-	    throw new TypeError("Cannot call a class as a function");
-	  }
-	};
-
-	var _extends = Object.assign || function (target) {
-	  for (var i = 1; i < arguments.length; i++) {
-	    var source = arguments[i];
-
-	    for (var key in source) {
-	      if (Object.prototype.hasOwnProperty.call(source, key)) {
-	        target[key] = source[key];
-	      }
-	    }
-	  }
-
-	  return target;
-	};
-
-	var inherits = function (subClass, superClass) {
-	  if (typeof superClass !== "function" && superClass !== null) {
-	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
-	  }
-
-	  subClass.prototype = Object.create(superClass && superClass.prototype, {
-	    constructor: {
-	      value: subClass,
-	      enumerable: false,
-	      writable: true,
-	      configurable: true
-	    }
-	  });
-	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
-	};
-
-	var possibleConstructorReturn = function (self, call) {
-	  if (!self) {
-	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
-	  }
-
-	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
-	};
-
-	var _this2 = undefined;
-
-	var createConnectedFetch = function createConnectedFetch() {
-	  var ConnectedFetch = function (_Component) {
-	    inherits(ConnectedFetch, _Component);
-
-	    function ConnectedFetch() {
-	      var _temp, _this, _ret;
-
-	      classCallCheck(this, ConnectedFetch);
-
-	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
-	        args[_key] = arguments[_key];
-	      }
-
-	      return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.rdfApi = _this.props.api, _this.rdfHeaders = _this.props.headers, _this.rdfInterceptor = _this.props.onIntercept, _this.rdfLoader = _this.props.loader, _this.rdfStore = _this.context && _this.context.store ? _this.context.store.getState() : _this.props.store, _this.rdfTimeout = _this.props.timeout, _this.componentWillReceiveProps = function () {
-	        return null;
-	      }, _temp), possibleConstructorReturn(_this, _ret);
-	    }
-
-	    ConnectedFetch.prototype.componentDidMount = function componentDidMount() {
-	      var message = '`<ConnectedFetch />` is deprecated and will be removed ' + 'in the next major version. ' + 'Please use `<FetchProvider />` instead.';
-
-	      {
-	        if (typeof console !== 'undefined') console.error(message);
-
-	        try {
-	          throw new Error(message);
-	        } catch (x) {} // eslint-disable-line
-	      }
-	    };
-
-	    ConnectedFetch.prototype.getChildContext = function getChildContext() {
-	      return {
-	        rdfApi: this.rdfApi || '',
-	        rdfHeaders: this.rdfHeaders,
-	        rdfInterceptor: this.rdfInterceptor,
-	        rdfLoader: this.rdfLoader,
-	        rdfStore: this.props.store || this.rdfStore,
-	        rdfTimeout: this.rdfTimeout
-	      };
-	    };
-
-	    ConnectedFetch.prototype.render = function render() {
-	      return react.Children.only(this.props.children);
-	    };
-
-	    return ConnectedFetch;
-	  }(react.Component);
-
-	  ConnectedFetch.defaultProps = {
-	    api: undefined,
-	    headers: {},
-	    loader: undefined,
-	    onIntercept: undefined,
-	    store: undefined,
-	    timeout: undefined
-	  };
-	  ConnectedFetch.propTypes = {
-	    api: propTypes.string,
-	    children: propTypes.element.isRequired,
-	    headers: propTypes.object,
-	    loader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-	    onIntercept: propTypes.func,
-	    store: storeShape,
-	    timeout: propTypes.number
-	  };
-	  ConnectedFetch.contextTypes = {
-	    store: storeShape
-	  };
-	  ConnectedFetch.childContextTypes = {
-	    rdfApi: propTypes.string,
-	    rdfHeaders: propTypes.object,
-	    rdfInterceptor: propTypes.func,
-	    rdfLoader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-	    rdfStore: propTypes.object,
-	    rdfTimeout: propTypes.number
-	  };
-
-
-	  {
-	    ConnectedFetch.prototype.componentWillReceiveProps = function (nextProps) {
-	      !(
-	      // $FlowFixMe
-	      _this2.rdfApi === nextProps.api) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `api` on the fly.') : invariant_1(false) : void 0;
-	      !(
-	      // $FlowFixMe
-	      _this2.rdfHeaders === nextProps.headers) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `headers` on the fly.') : invariant_1(false) : void 0;
-	      !(
-	      // $FlowFixMe
-	      _this2.rdfLoader === nextProps.loader) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `loader` on the fly.') : invariant_1(false) : void 0;
-	      !(
-	      // $FlowFixMe
-	      _this2.rdfInterceptor === nextProps.onIntercept) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `onIntercept` on the fly.') : invariant_1(false) : void 0;
-	      !(
-	      // $FlowFixMe
-	      _this2.rdfStore === nextProps.store) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `store` on the fly.') : invariant_1(false) : void 0;
-	      !(
-	      // $FlowFixMe
-	      _this2.rdfTimeout === nextProps.timeout) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<ConnectedFetch> does not support changing `timeout` on the fly.') : invariant_1(false) : void 0;
-	    };
-	  }
-
-	  return ConnectedFetch;
-	};
-
-	var ConnectedFetch = createConnectedFetch();
-
-	var runtime = createCommonjsModule(function (module) {
+	var runtime_1 = createCommonjsModule(function (module) {
 	/**
 	 * Copyright (c) 2014-present, Facebook, Inc.
 	 *
@@ -1001,44 +70,47 @@
 	 * LICENSE file in the root directory of this source tree.
 	 */
   
-	!(function(global) {
+	var runtime = (function (exports) {
   
 	  var Op = Object.prototype;
 	  var hasOwn = Op.hasOwnProperty;
-	  var undefined; // More compressible than void 0.
+	  var undefined$1; // More compressible than void 0.
 	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
 	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
 	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
 	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
-	  var runtime = global.regeneratorRuntime;
-	  if (runtime) {
-	    {
-	      // If regeneratorRuntime is defined globally and we're in a module,
-	      // make the exports object identical to regeneratorRuntime.
-	      module.exports = runtime;
-	    }
-	    // Don't bother evaluating the rest of this file if the runtime was
-	    // already defined globally.
-	    return;
-	  }
   
-	  // Define the runtime globally (as expected by generated code) as either
-	  // module.exports (if we're in a module) or a new, empty object.
-	  runtime = global.regeneratorRuntime = module.exports;
+	  function define(obj, key, value) {
+		Object.defineProperty(obj, key, {
+		  value: value,
+		  enumerable: true,
+		  configurable: true,
+		  writable: true
+		});
+		return obj[key];
+	  }
+	  try {
+		// IE 8 has a broken Object.defineProperty that only works on DOM objects.
+		define({}, "");
+	  } catch (err) {
+		define = function(obj, key, value) {
+		  return obj[key] = value;
+		};
+	  }
   
 	  function wrap(innerFn, outerFn, self, tryLocsList) {
-	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
-	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
-	    var generator = Object.create(protoGenerator.prototype);
-	    var context = new Context(tryLocsList || []);
+		// If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
+		var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
+		var generator = Object.create(protoGenerator.prototype);
+		var context = new Context(tryLocsList || []);
   
-	    // The ._invoke method unifies the implementations of the .next,
-	    // .throw, and .return methods.
-	    generator._invoke = makeInvokeMethod(innerFn, self, context);
+		// The ._invoke method unifies the implementations of the .next,
+		// .throw, and .return methods.
+		generator._invoke = makeInvokeMethod(innerFn, self, context);
   
-	    return generator;
+		return generator;
 	  }
-	  runtime.wrap = wrap;
+	  exports.wrap = wrap;
   
 	  // Try/catch helper to minimize deoptimizations. Returns a completion
 	  // record like context.tryEntries[i].completion. This interface could
@@ -1051,11 +123,11 @@
 	  // only additional allocation required is the completion record, which
 	  // has a stable shape and so hopefully should be cheap to allocate.
 	  function tryCatch(fn, obj, arg) {
-	    try {
-	      return { type: "normal", arg: fn.call(obj, arg) };
-	    } catch (err) {
-	      return { type: "throw", arg: err };
-	    }
+		try {
+		  return { type: "normal", arg: fn.call(obj, arg) };
+		} catch (err) {
+		  return { type: "throw", arg: err };
+		}
 	  }
   
 	  var GenStateSuspendedStart = "suspendedStart";
@@ -1079,239 +151,235 @@
 	  // don't natively support it.
 	  var IteratorPrototype = {};
 	  IteratorPrototype[iteratorSymbol] = function () {
-	    return this;
+		return this;
 	  };
   
 	  var getProto = Object.getPrototypeOf;
 	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
 	  if (NativeIteratorPrototype &&
-	      NativeIteratorPrototype !== Op &&
-	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
-	    // This environment has a native %IteratorPrototype%; use it instead
-	    // of the polyfill.
-	    IteratorPrototype = NativeIteratorPrototype;
+		  NativeIteratorPrototype !== Op &&
+		  hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
+		// This environment has a native %IteratorPrototype%; use it instead
+		// of the polyfill.
+		IteratorPrototype = NativeIteratorPrototype;
 	  }
   
 	  var Gp = GeneratorFunctionPrototype.prototype =
-	    Generator.prototype = Object.create(IteratorPrototype);
+		Generator.prototype = Object.create(IteratorPrototype);
 	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
 	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
-	  GeneratorFunctionPrototype[toStringTagSymbol] =
-	    GeneratorFunction.displayName = "GeneratorFunction";
+	  GeneratorFunction.displayName = define(
+		GeneratorFunctionPrototype,
+		toStringTagSymbol,
+		"GeneratorFunction"
+	  );
   
 	  // Helper for defining the .next, .throw, and .return methods of the
 	  // Iterator interface in terms of a single ._invoke method.
 	  function defineIteratorMethods(prototype) {
-	    ["next", "throw", "return"].forEach(function(method) {
-	      prototype[method] = function(arg) {
-	        return this._invoke(method, arg);
-	      };
-	    });
+		["next", "throw", "return"].forEach(function(method) {
+		  define(prototype, method, function(arg) {
+			return this._invoke(method, arg);
+		  });
+		});
 	  }
   
-	  runtime.isGeneratorFunction = function(genFun) {
-	    var ctor = typeof genFun === "function" && genFun.constructor;
-	    return ctor
-	      ? ctor === GeneratorFunction ||
-	        // For the native GeneratorFunction constructor, the best we can
-	        // do is to check its .name property.
-	        (ctor.displayName || ctor.name) === "GeneratorFunction"
-	      : false;
+	  exports.isGeneratorFunction = function(genFun) {
+		var ctor = typeof genFun === "function" && genFun.constructor;
+		return ctor
+		  ? ctor === GeneratorFunction ||
+			// For the native GeneratorFunction constructor, the best we can
+			// do is to check its .name property.
+			(ctor.displayName || ctor.name) === "GeneratorFunction"
+		  : false;
 	  };
   
-	  runtime.mark = function(genFun) {
-	    if (Object.setPrototypeOf) {
-	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
-	    } else {
-	      genFun.__proto__ = GeneratorFunctionPrototype;
-	      if (!(toStringTagSymbol in genFun)) {
-	        genFun[toStringTagSymbol] = "GeneratorFunction";
-	      }
-	    }
-	    genFun.prototype = Object.create(Gp);
-	    return genFun;
+	  exports.mark = function(genFun) {
+		if (Object.setPrototypeOf) {
+		  Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
+		} else {
+		  genFun.__proto__ = GeneratorFunctionPrototype;
+		  define(genFun, toStringTagSymbol, "GeneratorFunction");
+		}
+		genFun.prototype = Object.create(Gp);
+		return genFun;
 	  };
   
 	  // Within the body of any async function, `await x` is transformed to
 	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
 	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
 	  // meant to be awaited.
-	  runtime.awrap = function(arg) {
-	    return { __await: arg };
+	  exports.awrap = function(arg) {
+		return { __await: arg };
 	  };
   
-	  function AsyncIterator(generator) {
-	    function invoke(method, arg, resolve, reject) {
-	      var record = tryCatch(generator[method], generator, arg);
-	      if (record.type === "throw") {
-	        reject(record.arg);
-	      } else {
-	        var result = record.arg;
-	        var value = result.value;
-	        if (value &&
-	            typeof value === "object" &&
-	            hasOwn.call(value, "__await")) {
-	          return Promise.resolve(value.__await).then(function(value) {
-	            invoke("next", value, resolve, reject);
-	          }, function(err) {
-	            invoke("throw", err, resolve, reject);
-	          });
-	        }
-
-	        return Promise.resolve(value).then(function(unwrapped) {
-	          // When a yielded Promise is resolved, its final value becomes
-	          // the .value of the Promise<{value,done}> result for the
-	          // current iteration. If the Promise is rejected, however, the
-	          // result for this iteration will be rejected with the same
-	          // reason. Note that rejections of yielded Promises are not
-	          // thrown back into the generator function, as is the case
-	          // when an awaited Promise is rejected. This difference in
-	          // behavior between yield and await is important, because it
-	          // allows the consumer to decide what to do with the yielded
-	          // rejection (swallow it and continue, manually .throw it back
-	          // into the generator, abandon iteration, whatever). With
-	          // await, by contrast, there is no opportunity to examine the
-	          // rejection reason outside the generator function, so the
-	          // only option is to throw it from the await expression, and
-	          // let the generator function handle the exception.
-	          result.value = unwrapped;
-	          resolve(result);
-	        }, reject);
-	      }
-	    }
-
-	    var previousPromise;
-
-	    function enqueue(method, arg) {
-	      function callInvokeWithMethodAndArg() {
-	        return new Promise(function(resolve, reject) {
-	          invoke(method, arg, resolve, reject);
-	        });
-	      }
-
-	      return previousPromise =
-	        // If enqueue has been called before, then we want to wait until
-	        // all previous Promises have been resolved before calling invoke,
-	        // so that results are always delivered in the correct order. If
-	        // enqueue has not been called before, then it is important to
-	        // call invoke immediately, without waiting on a callback to fire,
-	        // so that the async generator function has the opportunity to do
-	        // any necessary setup in a predictable way. This predictability
-	        // is why the Promise constructor synchronously invokes its
-	        // executor callback, and why async functions synchronously
-	        // execute code before the first await. Since we implement simple
-	        // async functions in terms of async generators, it is especially
-	        // important to get this right, even though it requires care.
-	        previousPromise ? previousPromise.then(
-	          callInvokeWithMethodAndArg,
-	          // Avoid propagating failures to Promises returned by later
-	          // invocations of the iterator.
-	          callInvokeWithMethodAndArg
-	        ) : callInvokeWithMethodAndArg();
-	    }
-
-	    // Define the unified helper method that is used to implement .next,
-	    // .throw, and .return (see defineIteratorMethods).
-	    this._invoke = enqueue;
+	  function AsyncIterator(generator, PromiseImpl) {
+		function invoke(method, arg, resolve, reject) {
+		  var record = tryCatch(generator[method], generator, arg);
+		  if (record.type === "throw") {
+			reject(record.arg);
+		  } else {
+			var result = record.arg;
+			var value = result.value;
+			if (value &&
+				typeof value === "object" &&
+				hasOwn.call(value, "__await")) {
+			  return PromiseImpl.resolve(value.__await).then(function(value) {
+				invoke("next", value, resolve, reject);
+			  }, function(err) {
+				invoke("throw", err, resolve, reject);
+			  });
+			}
+  
+			return PromiseImpl.resolve(value).then(function(unwrapped) {
+			  // When a yielded Promise is resolved, its final value becomes
+			  // the .value of the Promise<{value,done}> result for the
+			  // current iteration.
+			  result.value = unwrapped;
+			  resolve(result);
+			}, function(error) {
+			  // If a rejected Promise was yielded, throw the rejection back
+			  // into the async generator function so it can be handled there.
+			  return invoke("throw", error, resolve, reject);
+			});
+		  }
+		}
+  
+		var previousPromise;
+  
+		function enqueue(method, arg) {
+		  function callInvokeWithMethodAndArg() {
+			return new PromiseImpl(function(resolve, reject) {
+			  invoke(method, arg, resolve, reject);
+			});
+		  }
+  
+		  return previousPromise =
+			// If enqueue has been called before, then we want to wait until
+			// all previous Promises have been resolved before calling invoke,
+			// so that results are always delivered in the correct order. If
+			// enqueue has not been called before, then it is important to
+			// call invoke immediately, without waiting on a callback to fire,
+			// so that the async generator function has the opportunity to do
+			// any necessary setup in a predictable way. This predictability
+			// is why the Promise constructor synchronously invokes its
+			// executor callback, and why async functions synchronously
+			// execute code before the first await. Since we implement simple
+			// async functions in terms of async generators, it is especially
+			// important to get this right, even though it requires care.
+			previousPromise ? previousPromise.then(
+			  callInvokeWithMethodAndArg,
+			  // Avoid propagating failures to Promises returned by later
+			  // invocations of the iterator.
+			  callInvokeWithMethodAndArg
+			) : callInvokeWithMethodAndArg();
+		}
+  
+		// Define the unified helper method that is used to implement .next,
+		// .throw, and .return (see defineIteratorMethods).
+		this._invoke = enqueue;
 	  }
   
 	  defineIteratorMethods(AsyncIterator.prototype);
 	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
-	    return this;
+		return this;
 	  };
-	  runtime.AsyncIterator = AsyncIterator;
+	  exports.AsyncIterator = AsyncIterator;
   
 	  // Note that simple async functions are implemented on top of
 	  // AsyncIterator objects; they just return a Promise for the value of
 	  // the final result produced by the iterator.
-	  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
-	    var iter = new AsyncIterator(
-	      wrap(innerFn, outerFn, self, tryLocsList)
-	    );
-
-	    return runtime.isGeneratorFunction(outerFn)
-	      ? iter // If outerFn is a generator, return the full iterator.
-	      : iter.next().then(function(result) {
-	          return result.done ? result.value : iter.next();
-	        });
+	  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
+		if (PromiseImpl === void 0) PromiseImpl = Promise;
+  
+		var iter = new AsyncIterator(
+		  wrap(innerFn, outerFn, self, tryLocsList),
+		  PromiseImpl
+		);
+  
+		return exports.isGeneratorFunction(outerFn)
+		  ? iter // If outerFn is a generator, return the full iterator.
+		  : iter.next().then(function(result) {
+			  return result.done ? result.value : iter.next();
+			});
 	  };
   
 	  function makeInvokeMethod(innerFn, self, context) {
-	    var state = GenStateSuspendedStart;
-
-	    return function invoke(method, arg) {
-	      if (state === GenStateExecuting) {
-	        throw new Error("Generator is already running");
-	      }
-
-	      if (state === GenStateCompleted) {
-	        if (method === "throw") {
-	          throw arg;
-	        }
-
-	        // Be forgiving, per 25.3.3.3.3 of the spec:
-	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
-	        return doneResult();
-	      }
-
-	      context.method = method;
-	      context.arg = arg;
-
-	      while (true) {
-	        var delegate = context.delegate;
-	        if (delegate) {
-	          var delegateResult = maybeInvokeDelegate(delegate, context);
-	          if (delegateResult) {
-	            if (delegateResult === ContinueSentinel) continue;
-	            return delegateResult;
-	          }
-	        }
-
-	        if (context.method === "next") {
-	          // Setting context._sent for legacy support of Babel's
-	          // function.sent implementation.
-	          context.sent = context._sent = context.arg;
-
-	        } else if (context.method === "throw") {
-	          if (state === GenStateSuspendedStart) {
-	            state = GenStateCompleted;
-	            throw context.arg;
-	          }
-
-	          context.dispatchException(context.arg);
-
-	        } else if (context.method === "return") {
-	          context.abrupt("return", context.arg);
-	        }
-
-	        state = GenStateExecuting;
-
-	        var record = tryCatch(innerFn, self, context);
-	        if (record.type === "normal") {
-	          // If an exception is thrown from innerFn, we leave state ===
-	          // GenStateExecuting and loop back for another invocation.
-	          state = context.done
-	            ? GenStateCompleted
-	            : GenStateSuspendedYield;
-
-	          if (record.arg === ContinueSentinel) {
-	            continue;
-	          }
-
-	          return {
-	            value: record.arg,
-	            done: context.done
-	          };
-
-	        } else if (record.type === "throw") {
-	          state = GenStateCompleted;
-	          // Dispatch the exception by looping back around to the
-	          // context.dispatchException(context.arg) call above.
-	          context.method = "throw";
-	          context.arg = record.arg;
-	        }
-	      }
-	    };
+		var state = GenStateSuspendedStart;
+  
+		return function invoke(method, arg) {
+		  if (state === GenStateExecuting) {
+			throw new Error("Generator is already running");
+		  }
+  
+		  if (state === GenStateCompleted) {
+			if (method === "throw") {
+			  throw arg;
+			}
+  
+			// Be forgiving, per 25.3.3.3.3 of the spec:
+			// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
+			return doneResult();
+		  }
+  
+		  context.method = method;
+		  context.arg = arg;
+  
+		  while (true) {
+			var delegate = context.delegate;
+			if (delegate) {
+			  var delegateResult = maybeInvokeDelegate(delegate, context);
+			  if (delegateResult) {
+				if (delegateResult === ContinueSentinel) continue;
+				return delegateResult;
+			  }
+			}
+  
+			if (context.method === "next") {
+			  // Setting context._sent for legacy support of Babel's
+			  // function.sent implementation.
+			  context.sent = context._sent = context.arg;
+  
+			} else if (context.method === "throw") {
+			  if (state === GenStateSuspendedStart) {
+				state = GenStateCompleted;
+				throw context.arg;
+			  }
+  
+			  context.dispatchException(context.arg);
+  
+			} else if (context.method === "return") {
+			  context.abrupt("return", context.arg);
+			}
+  
+			state = GenStateExecuting;
+  
+			var record = tryCatch(innerFn, self, context);
+			if (record.type === "normal") {
+			  // If an exception is thrown from innerFn, we leave state ===
+			  // GenStateExecuting and loop back for another invocation.
+			  state = context.done
+				? GenStateCompleted
+				: GenStateSuspendedYield;
+  
+			  if (record.arg === ContinueSentinel) {
+				continue;
+			  }
+  
+			  return {
+				value: record.arg,
+				done: context.done
+			  };
+  
+			} else if (record.type === "throw") {
+			  state = GenStateCompleted;
+			  // Dispatch the exception by looping back around to the
+			  // context.dispatchException(context.arg) call above.
+			  context.method = "throw";
+			  context.arg = record.arg;
+			}
+		  }
+		};
 	  }
   
 	  // Call delegate.iterator[context.method](context.arg) and handle the
@@ -1319,88 +387,89 @@
 	  // delegate iterator, or by modifying context.method and context.arg,
 	  // setting context.delegate to null, and returning the ContinueSentinel.
 	  function maybeInvokeDelegate(delegate, context) {
-	    var method = delegate.iterator[context.method];
-	    if (method === undefined) {
-	      // A .throw or .return when the delegate iterator has no .throw
-	      // method always terminates the yield* loop.
-	      context.delegate = null;
-
-	      if (context.method === "throw") {
-	        if (delegate.iterator.return) {
-	          // If the delegate iterator has a return method, give it a
-	          // chance to clean up.
-	          context.method = "return";
-	          context.arg = undefined;
-	          maybeInvokeDelegate(delegate, context);
-
-	          if (context.method === "throw") {
-	            // If maybeInvokeDelegate(context) changed context.method from
-	            // "return" to "throw", let that override the TypeError below.
-	            return ContinueSentinel;
-	          }
-	        }
-
-	        context.method = "throw";
-	        context.arg = new TypeError(
-	          "The iterator does not provide a 'throw' method");
-	      }
-
-	      return ContinueSentinel;
-	    }
-
-	    var record = tryCatch(method, delegate.iterator, context.arg);
-
-	    if (record.type === "throw") {
-	      context.method = "throw";
-	      context.arg = record.arg;
-	      context.delegate = null;
-	      return ContinueSentinel;
-	    }
-
-	    var info = record.arg;
-
-	    if (! info) {
-	      context.method = "throw";
-	      context.arg = new TypeError("iterator result is not an object");
-	      context.delegate = null;
-	      return ContinueSentinel;
-	    }
-
-	    if (info.done) {
-	      // Assign the result of the finished delegate to the temporary
-	      // variable specified by delegate.resultName (see delegateYield).
-	      context[delegate.resultName] = info.value;
-
-	      // Resume execution at the desired location (see delegateYield).
-	      context.next = delegate.nextLoc;
-
-	      // If context.method was "throw" but the delegate handled the
-	      // exception, let the outer generator proceed normally. If
-	      // context.method was "next", forget context.arg since it has been
-	      // "consumed" by the delegate iterator. If context.method was
-	      // "return", allow the original .return call to continue in the
-	      // outer generator.
-	      if (context.method !== "return") {
-	        context.method = "next";
-	        context.arg = undefined;
-	      }
-
-	    } else {
-	      // Re-yield the result returned by the delegate method.
-	      return info;
-	    }
-
-	    // The delegate iterator is finished, so forget it and continue with
-	    // the outer generator.
-	    context.delegate = null;
-	    return ContinueSentinel;
+		var method = delegate.iterator[context.method];
+		if (method === undefined$1) {
+		  // A .throw or .return when the delegate iterator has no .throw
+		  // method always terminates the yield* loop.
+		  context.delegate = null;
+  
+		  if (context.method === "throw") {
+			// Note: ["return"] must be used for ES3 parsing compatibility.
+			if (delegate.iterator["return"]) {
+			  // If the delegate iterator has a return method, give it a
+			  // chance to clean up.
+			  context.method = "return";
+			  context.arg = undefined$1;
+			  maybeInvokeDelegate(delegate, context);
+  
+			  if (context.method === "throw") {
+				// If maybeInvokeDelegate(context) changed context.method from
+				// "return" to "throw", let that override the TypeError below.
+				return ContinueSentinel;
+			  }
+			}
+  
+			context.method = "throw";
+			context.arg = new TypeError(
+			  "The iterator does not provide a 'throw' method");
+		  }
+  
+		  return ContinueSentinel;
+		}
+  
+		var record = tryCatch(method, delegate.iterator, context.arg);
+  
+		if (record.type === "throw") {
+		  context.method = "throw";
+		  context.arg = record.arg;
+		  context.delegate = null;
+		  return ContinueSentinel;
+		}
+  
+		var info = record.arg;
+  
+		if (! info) {
+		  context.method = "throw";
+		  context.arg = new TypeError("iterator result is not an object");
+		  context.delegate = null;
+		  return ContinueSentinel;
+		}
+  
+		if (info.done) {
+		  // Assign the result of the finished delegate to the temporary
+		  // variable specified by delegate.resultName (see delegateYield).
+		  context[delegate.resultName] = info.value;
+  
+		  // Resume execution at the desired location (see delegateYield).
+		  context.next = delegate.nextLoc;
+  
+		  // If context.method was "throw" but the delegate handled the
+		  // exception, let the outer generator proceed normally. If
+		  // context.method was "next", forget context.arg since it has been
+		  // "consumed" by the delegate iterator. If context.method was
+		  // "return", allow the original .return call to continue in the
+		  // outer generator.
+		  if (context.method !== "return") {
+			context.method = "next";
+			context.arg = undefined$1;
+		  }
+  
+		} else {
+		  // Re-yield the result returned by the delegate method.
+		  return info;
+		}
+  
+		// The delegate iterator is finished, so forget it and continue with
+		// the outer generator.
+		context.delegate = null;
+		return ContinueSentinel;
 	  }
   
 	  // Define Generator.prototype.{next,throw,return} in terms of the
 	  // unified ._invoke helper method.
 	  defineIteratorMethods(Gp);
   
-	  Gp[toStringTagSymbol] = "Generator";
+	  define(Gp, toStringTagSymbol, "Generator");
   
 	  // A Generator should always return itself as the iterator object when the
 	  // @@iterator function is called on it. Some browsers' implementations of the
@@ -1408,931 +477,567 @@
 	  // object to not be returned from this call. This ensures that doesn't happen.
 	  // See https://github.com/facebook/regenerator/issues/274 for more details.
 	  Gp[iteratorSymbol] = function() {
-	    return this;
+		return this;
 	  };
   
 	  Gp.toString = function() {
-	    return "[object Generator]";
+		return "[object Generator]";
 	  };
   
 	  function pushTryEntry(locs) {
-	    var entry = { tryLoc: locs[0] };
+		var entry = { tryLoc: locs[0] };
   
-	    if (1 in locs) {
-	      entry.catchLoc = locs[1];
-	    }
+		if (1 in locs) {
+		  entry.catchLoc = locs[1];
+		}
   
-	    if (2 in locs) {
-	      entry.finallyLoc = locs[2];
-	      entry.afterLoc = locs[3];
-	    }
+		if (2 in locs) {
+		  entry.finallyLoc = locs[2];
+		  entry.afterLoc = locs[3];
+		}
   
-	    this.tryEntries.push(entry);
+		this.tryEntries.push(entry);
 	  }
   
 	  function resetTryEntry(entry) {
-	    var record = entry.completion || {};
-	    record.type = "normal";
-	    delete record.arg;
-	    entry.completion = record;
+		var record = entry.completion || {};
+		record.type = "normal";
+		delete record.arg;
+		entry.completion = record;
 	  }
   
 	  function Context(tryLocsList) {
-	    // The root entry object (effectively a try statement without a catch
-	    // or a finally block) gives us a place to store values thrown from
-	    // locations where there is no enclosing try statement.
-	    this.tryEntries = [{ tryLoc: "root" }];
-	    tryLocsList.forEach(pushTryEntry, this);
-	    this.reset(true);
+		// The root entry object (effectively a try statement without a catch
+		// or a finally block) gives us a place to store values thrown from
+		// locations where there is no enclosing try statement.
+		this.tryEntries = [{ tryLoc: "root" }];
+		tryLocsList.forEach(pushTryEntry, this);
+		this.reset(true);
 	  }
   
-	  runtime.keys = function(object) {
-	    var keys = [];
-	    for (var key in object) {
-	      keys.push(key);
-	    }
-	    keys.reverse();
-
-	    // Rather than returning an object with a next method, we keep
-	    // things simple and return the next function itself.
-	    return function next() {
-	      while (keys.length) {
-	        var key = keys.pop();
-	        if (key in object) {
-	          next.value = key;
-	          next.done = false;
-	          return next;
-	        }
-	      }
-
-	      // To avoid creating an additional object, we just hang the .value
-	      // and .done properties off the next function object itself. This
-	      // also ensures that the minifier will not anonymize the function.
-	      next.done = true;
-	      return next;
-	    };
+	  exports.keys = function(object) {
+		var keys = [];
+		for (var key in object) {
+		  keys.push(key);
+		}
+		keys.reverse();
+  
+		// Rather than returning an object with a next method, we keep
+		// things simple and return the next function itself.
+		return function next() {
+		  while (keys.length) {
+			var key = keys.pop();
+			if (key in object) {
+			  next.value = key;
+			  next.done = false;
+			  return next;
+			}
+		  }
+  
+		  // To avoid creating an additional object, we just hang the .value
+		  // and .done properties off the next function object itself. This
+		  // also ensures that the minifier will not anonymize the function.
+		  next.done = true;
+		  return next;
+		};
 	  };
   
 	  function values(iterable) {
-	    if (iterable) {
-	      var iteratorMethod = iterable[iteratorSymbol];
-	      if (iteratorMethod) {
-	        return iteratorMethod.call(iterable);
-	      }
-
-	      if (typeof iterable.next === "function") {
-	        return iterable;
-	      }
-
-	      if (!isNaN(iterable.length)) {
-	        var i = -1, next = function next() {
-	          while (++i < iterable.length) {
-	            if (hasOwn.call(iterable, i)) {
-	              next.value = iterable[i];
-	              next.done = false;
-	              return next;
-	            }
-	          }
-
-	          next.value = undefined;
-	          next.done = true;
-
-	          return next;
-	        };
-
-	        return next.next = next;
-	      }
-	    }
-
-	    // Return an iterator with no values.
-	    return { next: doneResult };
+		if (iterable) {
+		  var iteratorMethod = iterable[iteratorSymbol];
+		  if (iteratorMethod) {
+			return iteratorMethod.call(iterable);
+		  }
+  
+		  if (typeof iterable.next === "function") {
+			return iterable;
+		  }
+  
+		  if (!isNaN(iterable.length)) {
+			var i = -1, next = function next() {
+			  while (++i < iterable.length) {
+				if (hasOwn.call(iterable, i)) {
+				  next.value = iterable[i];
+				  next.done = false;
+				  return next;
+				}
+			  }
+  
+			  next.value = undefined$1;
+			  next.done = true;
+  
+			  return next;
+			};
+  
+			return next.next = next;
+		  }
+		}
+  
+		// Return an iterator with no values.
+		return { next: doneResult };
 	  }
-	  runtime.values = values;
+	  exports.values = values;
   
 	  function doneResult() {
-	    return { value: undefined, done: true };
+		return { value: undefined$1, done: true };
 	  }
   
 	  Context.prototype = {
-	    constructor: Context,
-
-	    reset: function(skipTempReset) {
-	      this.prev = 0;
-	      this.next = 0;
-	      // Resetting context._sent for legacy support of Babel's
-	      // function.sent implementation.
-	      this.sent = this._sent = undefined;
-	      this.done = false;
-	      this.delegate = null;
-
-	      this.method = "next";
-	      this.arg = undefined;
-
-	      this.tryEntries.forEach(resetTryEntry);
-
-	      if (!skipTempReset) {
-	        for (var name in this) {
-	          // Not sure about the optimal order of these conditions:
-	          if (name.charAt(0) === "t" &&
-	              hasOwn.call(this, name) &&
-	              !isNaN(+name.slice(1))) {
-	            this[name] = undefined;
-	          }
-	        }
-	      }
-	    },
-
-	    stop: function() {
-	      this.done = true;
-
-	      var rootEntry = this.tryEntries[0];
-	      var rootRecord = rootEntry.completion;
-	      if (rootRecord.type === "throw") {
-	        throw rootRecord.arg;
-	      }
-
-	      return this.rval;
-	    },
-
-	    dispatchException: function(exception) {
-	      if (this.done) {
-	        throw exception;
-	      }
-
-	      var context = this;
-	      function handle(loc, caught) {
-	        record.type = "throw";
-	        record.arg = exception;
-	        context.next = loc;
-
-	        if (caught) {
-	          // If the dispatched exception was caught by a catch block,
-	          // then let that catch block handle the exception normally.
-	          context.method = "next";
-	          context.arg = undefined;
-	        }
-
-	        return !! caught;
-	      }
-
-	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
-	        var entry = this.tryEntries[i];
-	        var record = entry.completion;
-
-	        if (entry.tryLoc === "root") {
-	          // Exception thrown outside of any try block that could handle
-	          // it, so set the completion value of the entire function to
-	          // throw the exception.
-	          return handle("end");
-	        }
-
-	        if (entry.tryLoc <= this.prev) {
-	          var hasCatch = hasOwn.call(entry, "catchLoc");
-	          var hasFinally = hasOwn.call(entry, "finallyLoc");
-
-	          if (hasCatch && hasFinally) {
-	            if (this.prev < entry.catchLoc) {
-	              return handle(entry.catchLoc, true);
-	            } else if (this.prev < entry.finallyLoc) {
-	              return handle(entry.finallyLoc);
-	            }
-
-	          } else if (hasCatch) {
-	            if (this.prev < entry.catchLoc) {
-	              return handle(entry.catchLoc, true);
-	            }
-
-	          } else if (hasFinally) {
-	            if (this.prev < entry.finallyLoc) {
-	              return handle(entry.finallyLoc);
-	            }
-
-	          } else {
-	            throw new Error("try statement without catch or finally");
-	          }
-	        }
-	      }
-	    },
-
-	    abrupt: function(type, arg) {
-	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
-	        var entry = this.tryEntries[i];
-	        if (entry.tryLoc <= this.prev &&
-	            hasOwn.call(entry, "finallyLoc") &&
-	            this.prev < entry.finallyLoc) {
-	          var finallyEntry = entry;
-	          break;
-	        }
-	      }
-
-	      if (finallyEntry &&
-	          (type === "break" ||
-	           type === "continue") &&
-	          finallyEntry.tryLoc <= arg &&
-	          arg <= finallyEntry.finallyLoc) {
-	        // Ignore the finally entry if control is not jumping to a
-	        // location outside the try/catch block.
-	        finallyEntry = null;
-	      }
-
-	      var record = finallyEntry ? finallyEntry.completion : {};
-	      record.type = type;
-	      record.arg = arg;
-
-	      if (finallyEntry) {
-	        this.method = "next";
-	        this.next = finallyEntry.finallyLoc;
-	        return ContinueSentinel;
-	      }
-
-	      return this.complete(record);
-	    },
-
-	    complete: function(record, afterLoc) {
-	      if (record.type === "throw") {
-	        throw record.arg;
-	      }
-
-	      if (record.type === "break" ||
-	          record.type === "continue") {
-	        this.next = record.arg;
-	      } else if (record.type === "return") {
-	        this.rval = this.arg = record.arg;
-	        this.method = "return";
-	        this.next = "end";
-	      } else if (record.type === "normal" && afterLoc) {
-	        this.next = afterLoc;
-	      }
-
-	      return ContinueSentinel;
-	    },
-
-	    finish: function(finallyLoc) {
-	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
-	        var entry = this.tryEntries[i];
-	        if (entry.finallyLoc === finallyLoc) {
-	          this.complete(entry.completion, entry.afterLoc);
-	          resetTryEntry(entry);
-	          return ContinueSentinel;
-	        }
-	      }
-	    },
-
-	    "catch": function(tryLoc) {
-	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
-	        var entry = this.tryEntries[i];
-	        if (entry.tryLoc === tryLoc) {
-	          var record = entry.completion;
-	          if (record.type === "throw") {
-	            var thrown = record.arg;
-	            resetTryEntry(entry);
-	          }
-	          return thrown;
-	        }
-	      }
-
-	      // The context.catch method must only be called with a location
-	      // argument that corresponds to a known catch block.
-	      throw new Error("illegal catch attempt");
-	    },
-
-	    delegateYield: function(iterable, resultName, nextLoc) {
-	      this.delegate = {
-	        iterator: values(iterable),
-	        resultName: resultName,
-	        nextLoc: nextLoc
-	      };
-
-	      if (this.method === "next") {
-	        // Deliberately forget the last sent value so that we don't
-	        // accidentally pass it on to the delegate.
-	        this.arg = undefined;
-	      }
-
-	      return ContinueSentinel;
-	    }
-	  };
-	})(
-	  // In sloppy mode, unbound `this` refers to the global object, fallback to
-	  // Function constructor if we're in global strict mode. That is sadly a form
-	  // of indirect eval which violates Content Security Policy.
-	  (function() { return this })() || Function("return this")()
-	);
-	});
+		constructor: Context,
+  
+		reset: function(skipTempReset) {
+		  this.prev = 0;
+		  this.next = 0;
+		  // Resetting context._sent for legacy support of Babel's
+		  // function.sent implementation.
+		  this.sent = this._sent = undefined$1;
+		  this.done = false;
+		  this.delegate = null;
+  
+		  this.method = "next";
+		  this.arg = undefined$1;
+  
+		  this.tryEntries.forEach(resetTryEntry);
+  
+		  if (!skipTempReset) {
+			for (var name in this) {
+			  // Not sure about the optimal order of these conditions:
+			  if (name.charAt(0) === "t" &&
+				  hasOwn.call(this, name) &&
+				  !isNaN(+name.slice(1))) {
+				this[name] = undefined$1;
+			  }
+			}
+		  }
+		},
+  
+		stop: function() {
+		  this.done = true;
+  
+		  var rootEntry = this.tryEntries[0];
+		  var rootRecord = rootEntry.completion;
+		  if (rootRecord.type === "throw") {
+			throw rootRecord.arg;
+		  }
+  
+		  return this.rval;
+		},
+  
+		dispatchException: function(exception) {
+		  if (this.done) {
+			throw exception;
+		  }
+  
+		  var context = this;
+		  function handle(loc, caught) {
+			record.type = "throw";
+			record.arg = exception;
+			context.next = loc;
+  
+			if (caught) {
+			  // If the dispatched exception was caught by a catch block,
+			  // then let that catch block handle the exception normally.
+			  context.method = "next";
+			  context.arg = undefined$1;
+			}
   
-	/**
-	 * Copyright (c) 2014-present, Facebook, Inc.
-	 *
-	 * This source code is licensed under the MIT license found in the
-	 * LICENSE file in the root directory of this source tree.
-	 */
+			return !! caught;
+		  }
   
-	// This method of obtaining a reference to the global object needs to be
-	// kept identical to the way it is obtained in runtime.js
-	var g = (function() { return this })() || Function("return this")();
+		  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
+			var entry = this.tryEntries[i];
+			var record = entry.completion;
   
-	// Use `getOwnPropertyNames` because not all browsers support calling
-	// `hasOwnProperty` on the global `self` object in a worker. See #183.
-	var hadRuntime = g.regeneratorRuntime &&
-	  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;
+			if (entry.tryLoc === "root") {
+			  // Exception thrown outside of any try block that could handle
+			  // it, so set the completion value of the entire function to
+			  // throw the exception.
+			  return handle("end");
+			}
   
-	// Save the old regeneratorRuntime in case it needs to be restored later.
-	var oldRuntime = hadRuntime && g.regeneratorRuntime;
+			if (entry.tryLoc <= this.prev) {
+			  var hasCatch = hasOwn.call(entry, "catchLoc");
+			  var hasFinally = hasOwn.call(entry, "finallyLoc");
   
-	// Force reevalutation of runtime.js.
-	g.regeneratorRuntime = undefined;
+			  if (hasCatch && hasFinally) {
+				if (this.prev < entry.catchLoc) {
+				  return handle(entry.catchLoc, true);
+				} else if (this.prev < entry.finallyLoc) {
+				  return handle(entry.finallyLoc);
+				}
   
-	var runtimeModule = runtime;
+			  } else if (hasCatch) {
+				if (this.prev < entry.catchLoc) {
+				  return handle(entry.catchLoc, true);
+				}
   
-	if (hadRuntime) {
-	  // Restore the original runtime.
-	  g.regeneratorRuntime = oldRuntime;
-	} else {
-	  // Remove the global property added by runtime.js.
-	  try {
-	    delete g.regeneratorRuntime;
-	  } catch(e) {
-	    g.regeneratorRuntime = undefined;
-	  }
-	}
+			  } else if (hasFinally) {
+				if (this.prev < entry.finallyLoc) {
+				  return handle(entry.finallyLoc);
+				}
   
-	var regenerator = runtimeModule;
+			  } else {
+				throw new Error("try statement without catch or finally");
+			  }
+			}
+		  }
+		},
+  
+		abrupt: function(type, arg) {
+		  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
+			var entry = this.tryEntries[i];
+			if (entry.tryLoc <= this.prev &&
+				hasOwn.call(entry, "finallyLoc") &&
+				this.prev < entry.finallyLoc) {
+			  var finallyEntry = entry;
+			  break;
+			}
+		  }
+  
+		  if (finallyEntry &&
+			  (type === "break" ||
+			   type === "continue") &&
+			  finallyEntry.tryLoc <= arg &&
+			  arg <= finallyEntry.finallyLoc) {
+			// Ignore the finally entry if control is not jumping to a
+			// location outside the try/catch block.
+			finallyEntry = null;
+		  }
+  
+		  var record = finallyEntry ? finallyEntry.completion : {};
+		  record.type = type;
+		  record.arg = arg;
+  
+		  if (finallyEntry) {
+			this.method = "next";
+			this.next = finallyEntry.finallyLoc;
+			return ContinueSentinel;
+		  }
+  
+		  return this.complete(record);
+		},
+  
+		complete: function(record, afterLoc) {
+		  if (record.type === "throw") {
+			throw record.arg;
+		  }
+  
+		  if (record.type === "break" ||
+			  record.type === "continue") {
+			this.next = record.arg;
+		  } else if (record.type === "return") {
+			this.rval = this.arg = record.arg;
+			this.method = "return";
+			this.next = "end";
+		  } else if (record.type === "normal" && afterLoc) {
+			this.next = afterLoc;
+		  }
+  
+		  return ContinueSentinel;
+		},
+  
+		finish: function(finallyLoc) {
+		  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
+			var entry = this.tryEntries[i];
+			if (entry.finallyLoc === finallyLoc) {
+			  this.complete(entry.completion, entry.afterLoc);
+			  resetTryEntry(entry);
+			  return ContinueSentinel;
+			}
+		  }
+		},
+  
+		"catch": function(tryLoc) {
+		  for (var i = this.tryEntries.length - 1; i >= 0; --i) {
+			var entry = this.tryEntries[i];
+			if (entry.tryLoc === tryLoc) {
+			  var record = entry.completion;
+			  if (record.type === "throw") {
+				var thrown = record.arg;
+				resetTryEntry(entry);
+			  }
+			  return thrown;
+			}
+		  }
+  
+		  // The context.catch method must only be called with a location
+		  // argument that corresponds to a known catch block.
+		  throw new Error("illegal catch attempt");
+		},
+  
+		delegateYield: function(iterable, resultName, nextLoc) {
+		  this.delegate = {
+			iterator: values(iterable),
+			resultName: resultName,
+			nextLoc: nextLoc
+		  };
+  
+		  if (this.method === "next") {
+			// Deliberately forget the last sent value so that we don't
+			// accidentally pass it on to the delegate.
+			this.arg = undefined$1;
+		  }
+  
+		  return ContinueSentinel;
+		}
+	  };
   
-	var _this = undefined;
+	  // Regardless of whether this script is executing as a CommonJS module
+	  // or not, return the runtime object so that we can declare the variable
+	  // regeneratorRuntime in the outer scope, which allows this module to be
+	  // injected easily by `bin/regenerator --include-runtime script.js`.
+	  return exports;
+  
+	}(
+	  // If this script is executing as a CommonJS module, use module.exports
+	  // as the regeneratorRuntime namespace. Otherwise create a new empty
+	  // object. Either way, the resulting object will be used to initialize
+	  // the regeneratorRuntime variable at the top of this file.
+	   module.exports 
+	));
+  
+	try {
+	  regeneratorRuntime = runtime;
+	} catch (accidentalStrictMode) {
+	  // This module should not be running in strict mode, so the above
+	  // assignment should always work unless something is misconfigured. Just
+	  // in case runtime.js accidentally runs in strict mode, we can escape
+	  // strict mode using a global Function call. This could conceivably fail
+	  // if a Content Security Policy forbids using Function, but in that case
+	  // the proper solution is to fix the accidental strict mode problem. If
+	  // you've misconfigured your bundler to force strict mode and applied a
+	  // CSP to forbid Function, and you're not willing to fix either of those
+	  // problems, please detail your unique predicament in a GitHub issue.
+	  Function("r", "regeneratorRuntime = r")(runtime);
+	}
+	});
   
+	var regenerator = runtime_1;
+  
+	/* eslint no-return-assign: 0 */
 	var requestToApi = function requestToApi(args) {
 	  var body = args.body,
-	      headers = args.headers,
-	      method = args.method,
-	      _args$onProgress = args.onProgress,
-	      onProgress = _args$onProgress === undefined ? function () {
-	    return null;
+		  cancel = args.cancel,
+		  headers = args.headers,
+		  method = args.method,
+		  _args$onProgress = args.onProgress,
+		  onProgress = _args$onProgress === void 0 ? function () {
+		return null;
 	  } : _args$onProgress,
-	      onTimeout = args.onTimeout,
-	      params = args.params,
-	      onIntercept = args.onIntercept,
-	      url = args.url,
-	      _args$timeout = args.timeout,
-	      timeout = _args$timeout === undefined ? 0 : _args$timeout;
-
+		  onTimeout = args.onTimeout,
+		  params = args.params,
+		  onIntercept = args.onIntercept,
+		  url = args.url,
+		  _args$timeout = args.timeout,
+		  timeout = _args$timeout === void 0 ? 0 : _args$timeout,
+		  disableDefaultHeaders = args.disableDefaultHeaders;
 	  var defaultHeaders = {
-	    Accept: 'application/json;charset=UTF-8',
-	    'Content-Type': method === 'FORM_DATA' ? 'multipart/form-data' : 'application/json'
+		Accept: 'application/json;charset=UTF-8',
+		'Content-Type': method === 'FORM_DATA' ? 'multipart/form-data' : 'application/json'
 	  };
 	  var formData = new FormData();
 	  var route = url;
 	  var interceptedResult = null;
   
-	  var handleError = function () {
-	    var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(error, request, reject) {
-	      return regenerator.wrap(function _callee$(_context) {
-	        while (1) {
-	          switch (_context.prev = _context.next) {
-	            case 0:
-	              reject({
-	                response: request.response,
-	                request: request
-	              });
-
-	            case 1:
-	            case 'end':
-	              return _context.stop();
-	          }
-	        }
-	      }, _callee, _this);
-	    }));
-
-	    return function handleError(_x, _x2, _x3) {
-	      return _ref.apply(this, arguments);
-	    };
+	  var handleError = /*#__PURE__*/function () {
+		var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(error, request, reject) {
+		  return regenerator.wrap(function _callee$(_context) {
+			while (1) {
+			  switch (_context.prev = _context.next) {
+				case 0:
+				  reject({
+					response: request.response,
+					request: request
+				  });
+  
+				case 1:
+				case "end":
+				  return _context.stop();
+			  }
+			}
+		  }, _callee);
+		}));
+  
+		return function handleError(_x, _x2, _x3) {
+		  return _ref.apply(this, arguments);
+		};
 	  }();
   
 	  var handleTimeout = function handleTimeout(request, reject) {
-	    request.abort();
-	    if (onTimeout) onTimeout();
-	    reject('Your request took more than ' + timeout + 'ms to resolve.');
+		request.abort();
+		if (onTimeout) onTimeout();
+		reject("Your request took more than " + timeout + "ms to resolve.");
 	  };
   
-	  var returnData = function () {
-	    var _ref2 = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(request, resolve, reject) {
-	      var isOK, data, response;
-	      return regenerator.wrap(function _callee2$(_context2) {
-	        while (1) {
-	          switch (_context2.prev = _context2.next) {
-	            case 0:
-	              if (request.readyState === 4) {
-	                isOK = request.status >= 200 && request.status <= 299;
-
-	                if (isOK) {
-	                  data = void 0;
-
-	                  try {
-	                    if (request.responseText) data = JSON.parse(request.responseText);
-	                  } catch (err) {
-	                    data = request.responseText;
-	                  }
-	                  response = {
-	                    data: data,
-	                    isOK: isOK,
-	                    request: request,
-	                    status: request.status
-	                  };
-
-	                  resolve(response);
-	                } else if (onIntercept) {
-	                  interceptedResult = onIntercept({
-	                    currentParams: args,
-	                    request: request,
-	                    status: request.status
-	                  });
-	                  if (interceptedResult) {
-	                    resolve(requestToApi(_extends({}, interceptedResult, {
-	                      onIntercept: undefined
-	                    })));
-	                  } else handleError(request, request, reject);
-	                } else handleError(request, request, reject);
-	              }
-
-	            case 1:
-	            case 'end':
-	              return _context2.stop();
-	          }
-	        }
-	      }, _callee2, _this);
-	    }));
-
-	    return function returnData(_x4, _x5, _x6) {
-	      return _ref2.apply(this, arguments);
-	    };
+	  var returnData = /*#__PURE__*/function () {
+		var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(request, resolve, reject, isCancel) {
+		  var response, isOK, _response;
+  
+		  return regenerator.wrap(function _callee2$(_context2) {
+			while (1) {
+			  switch (_context2.prev = _context2.next) {
+				case 0:
+				  if (isCancel) {
+					response = {
+					  data: {
+						cancelled: true
+					  },
+					  isOK: true,
+					  request: request,
+					  status: request.status
+					};
+					resolve(response);
+				  }
+  
+				  if (!(request.readyState === 4)) {
+					_context2.next = 20;
+					break;
+				  }
+  
+				  isOK = request.status >= 200 && request.status <= 299;
+  
+				  if (!isOK) {
+					_context2.next = 19;
+					break;
+				  }
+  
+				  if (!request.responseText) {
+					_context2.next = 10;
+					break;
+				  }
+  
+				  _context2.next = 7;
+				  return JSON.parse(request.responseText);
+  
+				case 7:
+				  _context2.t0 = _context2.sent;
+				  _context2.next = 11;
+				  break;
+  
+				case 10:
+				  _context2.t0 = undefined;
+  
+				case 11:
+				  _context2.t1 = _context2.t0;
+				  _context2.t2 = isOK;
+				  _context2.t3 = request;
+				  _context2.t4 = request.status;
+				  _response = {
+					data: _context2.t1,
+					isOK: _context2.t2,
+					request: _context2.t3,
+					status: _context2.t4
+				  };
+				  resolve(_response);
+				  _context2.next = 20;
+				  break;
+  
+				case 19:
+				  if (onIntercept) {
+					interceptedResult = onIntercept({
+					  currentParams: args,
+					  request: request,
+					  status: request.status
+					});
+  
+					if (interceptedResult) {
+					  resolve(requestToApi(_extends({}, interceptedResult, {
+						onIntercept: undefined
+					  })));
+					} else handleError(request, request, reject);
+				  } else handleError(request, request, reject);
+  
+				case 20:
+				case "end":
+				  return _context2.stop();
+			  }
+			}
+		  }, _callee2);
+		}));
+  
+		return function returnData(_x4, _x5, _x6, _x7) {
+		  return _ref2.apply(this, arguments);
+		};
 	  }();
   
 	  var setHeaders = function setHeaders(request) {
-	    Object.entries(defaultHeaders).map(function (defaultHeader) {
-	      return request.setRequestHeader(defaultHeader[0], String(defaultHeader[1]));
-	    });
-	    if (headers && Object.keys(headers).length > 0) {
-	      Object.entries(headers).map(function (header) {
-	        return request.setRequestHeader(header[0], String(header[1]));
-	      });
-	    }
+		if (!disableDefaultHeaders) {
+		  Object.entries(defaultHeaders).map(function (defaultHeader) {
+			return request.setRequestHeader(defaultHeader[0], String(defaultHeader[1]));
+		  });
+		}
+  
+		if (headers && Object.keys(headers).length > 0) {
+		  Object.entries(headers).map(function (header) {
+			return request.setRequestHeader(header[0], String(header[1]));
+		  });
+		}
 	  };
   
 	  if (method === 'FORM_DATA' && Object.entries(body).length > 0) {
-	    Object.entries(body).map(
-	    // $FlowFixMe
-	    function (entry) {
-	      return formData.append(entry[0], entry[1]);
-	    });
+		Object.entries(body).map( // $FlowFixMe
+		function (entry) {
+		  return formData.append(entry[0], entry[1]);
+		});
 	  }
   
 	  if (params && Object.keys(params).length > 0) {
-	    Object.entries(params).map(function (param, index) {
-	      return index === 0 ? route = route + '?' + param[0] + '=' + JSON.stringify(param[1]) : route = route + '&' + param[0] + '=' + JSON.stringify(param[1]);
-	    });
+		Object.entries(params).map(function (param, index) {
+		  return index === 0 ? route = route + "?" + param[0] + "=" + JSON.stringify(param[1]) : route = route + "&" + param[0] + "=" + JSON.stringify(param[1]);
+		});
 	  }
   
 	  var sendRequest = function sendRequest() {
-	    return new Promise(function (resolve, reject) {
-	      try {
-	        var request = new XMLHttpRequest();
-	        if (request.upload) {
-	          request.upload.onerror = function (error) {
-	            return handleError(error, request, resolve);
-	          };
-	          request.upload.onload = function () {
-	            return returnData(request, resolve, reject);
-	          };
-	          request.upload.onprogress = onProgress;
-	          request.upload.ontimeout = function () {
-	            return handleTimeout(request, reject);
-	          };
-	        }
-
-	        request.onerror = function (error) {
-	          return handleError(error, request, resolve);
-	        };
-	        request.onprogress = onProgress;
-	        request.onreadystatechange = function () {
-	          return returnData(request, resolve, reject);
-	        };
-	        request.ontimeout = function () {
-	          return handleTimeout(request, reject);
-	        };
-
-	        request.open(method === 'FORM_DATA' ? 'POST' : method, route);
-	        request.timeout = timeout;
-	        setHeaders(request);
-	        request.send(method === 'FORM_DATA' ? formData : method === 'DELETE' || method === 'GET' || method === 'HEAD' || method === 'PUT' ? null : JSON.stringify(_extends({}, body)));
-	      } catch (request) {
-	        handleError(request, request, reject);
-	      }
-	    });
-	  };
-
-	  return sendRequest();
-	};
-
-	var isEmptyChildren = function isEmptyChildren(children) {
-	  return react.Children.count(children) === 0;
-	};
-
-	var Fetch = function (_Component) {
-	  inherits(Fetch, _Component);
-
-	  function Fetch() {
-	    var _this2 = this;
-
-	    var _temp, _this, _ret;
-
-	    classCallCheck(this, Fetch);
-
-	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
-	      args[_key] = arguments[_key];
-	    }
-
-	    return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this._data = undefined, _this._didCallOnLoad = false, _this._isLoaded = false, _this._isUnmounted = false, _this._fetchData = function () {
-	      var _ref = asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(props, context) {
-	        var body, headers, method, onIntercept, onProgress, onTimeout, params, path, url, timeout, route, timeoutValue, apiResponse;
-	        return regenerator.wrap(function _callee$(_context) {
-	          while (1) {
-	            switch (_context.prev = _context.next) {
-	              case 0:
-	                body = props.body, headers = props.headers, method = props.method, onIntercept = props.onIntercept, onProgress = props.onProgress, onTimeout = props.onTimeout, params = props.params, path = props.path, url = props.url, timeout = props.timeout;
-	                route = void 0;
-	                timeoutValue = 0;
-
-
-	                if (path) route = '' + (context.rdfApi || '') + path;else route = url;
-
-	                if (context.rdfTimeout && timeout === -1) timeoutValue = context.rdfTimeout;else if (!context.rdfTimeout && timeout) timeoutValue = Math.max(0, timeout);else if (context.rdfTimeout && timeout) timeoutValue = timeout === -1 ? context.rdfTimeout : timeout;
-
-	                _context.prev = 5;
-	                _context.next = 8;
-	                return requestToApi({
-	                  url: route || '',
-	                  body: _extends({}, body),
-	                  headers: _extends({}, context.rdfHeaders, headers),
-	                  method: method,
-	                  onTimeout: onTimeout,
-	                  onProgress: onProgress,
-	                  onIntercept: onIntercept || context.rdfInterceptor,
-	                  params: _extends({}, params),
-	                  timeout: timeoutValue
-	                });
-
-	              case 8:
-	                apiResponse = _context.sent;
-
-	                if (!_this._isUnmounted) {
-	                  _this._handleData(_extends({}, apiResponse, {
-	                    store: context.rdfStore
-	                  }));
-	                }
-	                _context.next = 15;
-	                break;
-
-	              case 12:
-	                _context.prev = 12;
-	                _context.t0 = _context['catch'](5);
-
-	                if (!_this._isUnmounted) {
-	                  _this._handleData({
-	                    error: {
-	                      content: _context.t0,
-	                      message: 'Something went wrong during the request',
-	                      url: route
-	                    },
-	                    isOK: false,
-	                    store: context.rdfStore
-	                  });
-	                  {
-	                    !!_context.t0 ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<Fetch /> tried to call the route "' + String(route) + '" ' + ('with "' + String(method).toUpperCase() + '" method ') + 'but resolved with the following error: %s\n', _this._printError(_context.t0)) : invariant_1(false) : void 0;
-	                  }
-	                }
-
-	              case 15:
-	              case 'end':
-	                return _context.stop();
-	            }
-	          }
-	        }, _callee, _this2, [[5, 12]]);
-	      }));
-
-	      return function (_x, _x2) {
-	        return _ref.apply(this, arguments);
-	      };
-	    }(), _this._handleData = function (result) {
-	      if (!_this._isUnmounted) {
-	        _this._isLoaded = true;
-	        _this.props.resultOnly ? _this._data = result.error || result.data : _this._data = result;
-	        _this._returnData(result);
-	      }
-	    }, _this._printError = function (error) {
-	      return error.response && JSON.stringify(error.response).length ? typeof error.response === 'string' ? error.response : _typeof(error.response) === 'object' ? JSON.stringify(error.response, null, 2) : error.response + '. Sorry <Fetch /> couldn\'t turned this into a readable string. ' + 'Check error.content.request to see what happened.' : " .Sorry <Fetch /> couldn't turned this into a readable string. " + 'Check error.content.request to see what happened.';
-	    }, _this._renderLoader = function () {
-	      var rdfLoader = _this.context.rdfLoader;
-	      var loader = _this.props.loader;
-
-
-	      if (rdfLoader && !loader) return typeof rdfLoader === 'function' ? rdfLoader() : rdfLoader;
-	      if (!rdfLoader && loader) return typeof loader === 'function' ? loader() : loader;
-	      if (rdfLoader && loader) return typeof loader === 'function' ? loader() : loader;
-
-	      return null;
-	    }, _this._returnData = function (result) {
-	      var _this$props = _this.props,
-	          onError = _this$props.onError,
-	          onFetch = _this$props.onFetch;
-
-
-	      if (onFetch) onFetch(_this._data);
-
-	      if (result.error && onError) onError(_this._data);
-
-	      if (!_this._isUnmounted) _this.forceUpdate();
-	    }, _this._validateProps = function (props, context) {
-	      var rdfApi = context.rdfApi,
-	          rdfStore = context.rdfStore,
-	          rdfTimeout = context.rdfTimeout;
-	      var children = props.children,
-	          component = props.component,
-	          onTimeout = props.onTimeout,
-	          onFetch = props.onFetch,
-	          path = props.path,
-	          refetch = props.refetch,
-	          render = props.render,
-	          timeout = props.timeout,
-	          url = props.url;
-
-
-	      !(path || url) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must provide a `url` or a `path` to <Fetch />') : invariant_1(false) : void 0;
-
-	      if (path) {
-	        !(path && rdfApi) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must implement <FetchProvider> at the root of your ' + 'app and provide an `api` in order to use `path`') : invariant_1(false) : void 0;
-	      }
-
-	      if (path === 'store') {
-	        !(path && rdfStore) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must implement <FetchProvider> at the root of your ' + 'app and provide a `store` in order to use `path="store"`') : invariant_1(false) : void 0;
-	      }
-
-	      if (onTimeout) {
-	        !(typeof timeout === 'number' && timeout >= 0 || typeof rdfTimeout === 'number' && rdfTimeout >= 0) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must provide a `timeout` number in ms to <Fetch /> or ' + '<FetchProvider> in order to use `onTimeout`') : invariant_1(false) : void 0;
-	      }
-
-	      !(children || component || render || onFetch) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, 'You must provide at least one of the following ' + 'to <Fetch />: children, `component`, `onFetch`, `render`') : invariant_1(false) : void 0;
-
-	      if (typeof refetch !== 'undefined') {
-	        var message = '`refetch` is deprecated and will be removed ' + 'in the next major version. ' + 'Please use `refetchKey` instead.';
-
-	        {
-	          if (typeof console !== 'undefined') console.error(message);
-
-	          try {
-	            throw new Error(message);
-	          } catch (x) {} // eslint-disable-line
-	        }
-	      }
-	    }, _temp), possibleConstructorReturn(_this, _ret);
-	  }
-
-	  Fetch.prototype.componentWillMount = function componentWillMount() {
-	    this._validateProps(this.props, this.context);
-	    if (this.props.onLoad && !this._didCallOnLoad) {
-	      this._didCallOnLoad = true;
-	      this.props.onLoad();
-	    }
-	  };
-
-	  Fetch.prototype.componentDidMount = function componentDidMount() {
-	    if (this.props.path === 'store') {
-	      this._handleData({
-	        data: this.context.rdfStore,
-	        isOK: true
-	      });
-	    } else this._fetchData(this.props, this.context);
-	  };
-
-	  Fetch.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps, nextContext) {
-	    var _props = this.props,
-	        onLoad = _props.onLoad,
-	        path = _props.path,
-	        refetch = _props.refetch,
-	        refetchKey = _props.refetchKey;
-
-
-	    this._validateProps(nextProps, nextContext);
-
-	    if (onLoad && !this._didCallOnLoad) {
-	      this._didCallOnLoad = true;
-	      onLoad();
-	    }
-
-	    if (path === 'store') {
-	      this._handleData({
-	        data: this.context.rdfStore,
-	        isOK: true
-	      });
-	    } else if (nextProps.path !== path || nextProps.refetch !== refetch || nextProps.refetchKey !== refetchKey) {
-	      this._isLoaded = false;
-	      this._fetchData(nextProps, nextContext);
-	    }
-	  };
-
-	  Fetch.prototype.componentWillUnmount = function componentWillUnmount() {
-	    this._isUnmounted = true;
-	  };
-
-	  Fetch.prototype.shouldComponentUpdate = function shouldComponentUpdate(nextProps) {
-	    if (this.props.children !== nextProps.children) return true;
-	    if (this.props.loader !== nextProps.loader) return true;
-	    if (this.props.onError !== nextProps.onError) return true;
-	    if (this.props.onFetch !== nextProps.onFetch) return true;
-	    if (this.props.onLoad !== nextProps.onLoad) return true;
-	    if (this.props.path !== nextProps.path) return true;
-	    if (this.props.params !== nextProps.params) return true;
-	    if (this.props.refetch !== nextProps.refetch) return true;
-	    if (this.props.refetchKey !== nextProps.refetchKey) return true;
-	    if (this.props.render !== nextProps.render) return true;
-	    if (this._isLoaded) return true;
-	    if (this._data) return true;
-	    return false;
-	  };
-
-	  Fetch.prototype.render = function render() {
-	    var _props2 = this.props,
-	        children = _props2.children,
-	        component = _props2.component,
-	        render = _props2.render;
+		return new Promise(function (resolve, reject) {
+		  try {
+			var request = new XMLHttpRequest();
   
+			if (request.upload) {
+			  request.upload.onerror = function (error) {
+				return handleError(error, request, resolve);
+			  };
   
-	    if (!this._isLoaded && !this._isUnmounted) return this._renderLoader();
+			  request.upload.onload = function () {
+				return returnData(request, resolve, reject);
+			  };
   
-	    if (this._isLoaded && !this._isUnmounted) {
-	      if (component) return react.createElement(component, this._data);
+			  request.upload.onprogress = onProgress;
   
-	      if (typeof render === 'function') return render(this._data);
-
-	      if (typeof children === 'function') return children(this._data);
-
-	      if (children && !isEmptyChildren(children)) return react.Children.only(children);
-	    }
+			  request.upload.ontimeout = function () {
+				return handleTimeout(request, reject);
+			  };
+			}
   
-	    return null;
+			request.onerror = function (error) {
+			  return handleError(error, request, resolve);
+			};
+  
+			request.onprogress = onProgress;
+  
+			request.onreadystatechange = function () {
+			  return returnData(request, resolve, reject);
+			};
+  
+			request.ontimeout = function () {
+			  return handleTimeout(request, reject);
+			};
+  
+			request.open(method === 'FORM_DATA' ? 'POST' : method, route);
+			request.timeout = timeout;
+			setHeaders(request);
+			if (cancel) returnData(request, resolve, reject, true);
+			request.send(method === 'FORM_DATA' ? formData : method === 'DELETE' || method === 'HEAD' ? null : JSON.stringify(_extends({}, body)));
+			if (cancel) request.abort();
+		  } catch (request) {
+			handleError(request, request, reject);
+		  }
+		});
 	  };
   
-	  return Fetch;
-	}(react.Component);
-
-	Fetch.propTypes = {
-	  body: propTypes.object,
-	  children: propTypes.oneOfType([propTypes.element, propTypes.func]),
-	  component: propTypes.oneOfType([propTypes.element, propTypes.func]),
-	  method: methodShape,
-	  loader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-	  onError: propTypes.func,
-	  onFetch: propTypes.func,
-	  onLoad: propTypes.func,
-	  onProgress: propTypes.func,
-	  onTimeout: propTypes.func,
-	  params: propTypes.object,
-	  path: propTypes.string,
-	  refetch: propTypes.any,
-	  refetchKey: propTypes.any,
-	  render: propTypes.func,
-	  resultOnly: propTypes.bool,
-	  url: propTypes.string,
-	  timeout: propTypes.number
-	};
-	Fetch.contextTypes = {
-	  rdfApi: propTypes.string,
-	  rdfHeaders: propTypes.object,
-	  rdfInterceptor: propTypes.func,
-	  rdfLoader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-	  rdfStore: propTypes.object,
-	  rdfTimeout: propTypes.number
-	};
-	Fetch.defaultProps = {
-	  body: {},
-	  children: undefined,
-	  component: undefined,
-	  loader: undefined,
-	  method: 'GET',
-	  onError: undefined,
-	  onFetch: undefined,
-	  onLoad: undefined,
-	  onProgress: undefined,
-	  onTimeout: undefined,
-	  params: {},
-	  path: undefined,
-	  refetch: undefined,
-	  refetchKey: undefined,
-	  render: undefined,
-	  resultOnly: false,
-	  url: undefined,
-	  timeout: -1
-	};
-
-	var _this2$1 = undefined;
-
-	var createFetchProvider = function createFetchProvider() {
-	  var FetchProvider = function (_Component) {
-	    inherits(FetchProvider, _Component);
-
-	    function FetchProvider() {
-	      var _temp, _this, _ret;
-
-	      classCallCheck(this, FetchProvider);
-
-	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
-	        args[_key] = arguments[_key];
-	      }
-
-	      return _ret = (_temp = (_this = possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.rdfApi = _this.props.api, _this.rdfHeaders = _this.props.headers, _this.rdfInterceptor = _this.props.onIntercept, _this.rdfLoader = _this.props.loader, _this.rdfStore = _this.context && _this.context.store ? _this.context.store.getState() : _this.props.store, _this.rdfTimeout = _this.props.timeout, _this.componentWillReceiveProps = function () {
-	        return null;
-	      }, _temp), possibleConstructorReturn(_this, _ret);
-	    }
-
-	    FetchProvider.prototype.getChildContext = function getChildContext() {
-	      return {
-	        rdfApi: this.rdfApi || '',
-	        rdfHeaders: this.rdfHeaders,
-	        rdfInterceptor: this.rdfInterceptor,
-	        rdfLoader: this.rdfLoader,
-	        rdfStore: this.props.store || this.rdfStore,
-	        rdfTimeout: this.rdfTimeout
-	      };
-	    };
-
-	    FetchProvider.prototype.render = function render() {
-	      return react.Children.only(this.props.children);
-	    };
-
-	    return FetchProvider;
-	  }(react.Component);
-
-	  FetchProvider.defaultProps = {
-	    api: undefined,
-	    headers: {},
-	    loader: undefined,
-	    onIntercept: undefined,
-	    store: undefined,
-	    timeout: undefined
-	  };
-	  FetchProvider.propTypes = {
-	    api: propTypes.string,
-	    children: propTypes.element.isRequired,
-	    headers: propTypes.object,
-	    loader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-	    onIntercept: propTypes.func,
-	    store: storeShape,
-	    timeout: propTypes.number
-	  };
-	  FetchProvider.contextTypes = {
-	    store: storeShape
-	  };
-	  FetchProvider.childContextTypes = {
-	    rdfApi: propTypes.string,
-	    rdfHeaders: propTypes.object,
-	    rdfInterceptor: propTypes.func,
-	    rdfLoader: propTypes.oneOfType([propTypes.element, propTypes.func]),
-	    rdfStore: propTypes.object,
-	    rdfTimeout: propTypes.number
-	  };
-
-
-	  {
-	    FetchProvider.prototype.componentWillReceiveProps = function (nextProps) {
-	      !(
-	      // $FlowFixMe
-	      _this2$1.rdfApi === nextProps.api) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `api` on the fly.') : invariant_1(false) : void 0;
-	      !(
-	      // $FlowFixMe
-	      _this2$1.rdfHeaders === nextProps.headers) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `headers` on the fly.') : invariant_1(false) : void 0;
-	      !(
-	      // $FlowFixMe
-	      _this2$1.rdfLoader === nextProps.loader) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `loader` on the fly.') : invariant_1(false) : void 0;
-	      !(
-	      // $FlowFixMe
-	      _this2$1.rdfInterceptor === nextProps.onIntercept) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `onIntercept` on the fly.') : invariant_1(false) : void 0;
-	      !(
-	      // $FlowFixMe
-	      _this2$1.rdfStore === nextProps.store) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `store` on the fly.') : invariant_1(false) : void 0;
-	      !(
-	      // $FlowFixMe
-	      _this2$1.rdfTimeout === nextProps.timeout) ? process.env.NODE_ENV !== 'production' ? invariant_1(false, '<FetchProvider> does not support changing `timeout` on the fly.') : invariant_1(false) : void 0;
-	    };
-	  }
-
-	  return FetchProvider;
+	  return sendRequest();
 	};
   
-	var FetchProvider = createFetchProvider();
-
-	exports.ConnectedFetch = ConnectedFetch;
-	exports.Fetch = Fetch;
-	exports.FetchProvider = FetchProvider;
-	exports.requestToApi = requestToApi;
+	return requestToApi;
   
-	Object.defineProperty(exports, '__esModule', { value: true });
+  })));
   
\ No newline at end of file
-})));
diff --git a/node_modules/react-data-fetching/umd/react-data-fetching.min.js b/node_modules/react-data-fetching/umd/react-data-fetching.min.js
index 2322eae..344b05b 100644
--- a/node_modules/react-data-fetching/umd/react-data-fetching.min.js
+++ b/node_modules/react-data-fetching/umd/react-data-fetching.min.js
@@ -1 +1,2 @@
-!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],e):e(t.ReactDataFetching={},t.React)}(this,function(t,e){"use strict";function r(t,e){return t(e={exports:{}},e.exports),e.exports}var o="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";function n(){}var i=r(function(t){t.exports=function(){function t(t,e,r,n,i,a){if(a!==o){var s=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw s.name="Invariant Violation",s}}function e(){return t}t.isRequired=t;var r={array:t,bool:t,func:t,number:t,object:t,string:t,symbol:t,any:t,arrayOf:e,element:t,instanceOf:e,node:t,objectOf:e,oneOf:e,oneOfType:e,shape:e,exact:e};return r.checkPropTypes=n,r.PropTypes=r,r}()}),a=function(t,e,r,o,n,i,a,s){if(!t){var c;if(void 0===e)c=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var u=[r,o,n,i,a,s],p=0;(c=new Error(e.replace(/%s/g,function(){return u[p++]}))).name="Invariant Violation"}throw c.framesToPop=1,c}},s=(i.oneOf(["DELETE","FORM_DATA","GET","HEAD","PATCH","POST","PUT","TRACE"]),i.shape({getState:i.func})),c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},u=function(t){return function(){var e=t.apply(this,arguments);return new Promise(function(t,r){return function o(n,i){try{var a=e[n](i),s=a.value}catch(t){return void r(t)}if(!a.done)return Promise.resolve(s).then(function(t){o("next",t)},function(t){o("throw",t)});t(s)}("next")})}},p=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")},f=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(t[o]=r[o])}return t},d=function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)},h=function(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e},l=function(){var t=function(t){function r(){var e,o;p(this,r);for(var n=arguments.length,i=Array(n),a=0;a<n;a++)i[a]=arguments[a];return e=o=h(this,t.call.apply(t,[this].concat(i))),o.rdfApi=o.props.api,o.rdfHeaders=o.props.headers,o.rdfInterceptor=o.props.onIntercept,o.rdfLoader=o.props.loader,o.rdfStore=o.context&&o.context.store?o.context.store.getState():o.props.store,o.rdfTimeout=o.props.timeout,o.componentWillReceiveProps=function(){return null},h(o,e)}return d(r,t),r.prototype.componentDidMount=function(){},r.prototype.getChildContext=function(){return{rdfApi:this.rdfApi||"",rdfHeaders:this.rdfHeaders,rdfInterceptor:this.rdfInterceptor,rdfLoader:this.rdfLoader,rdfStore:this.props.store||this.rdfStore,rdfTimeout:this.rdfTimeout}},r.prototype.render=function(){return e.Children.only(this.props.children)},r}(e.Component);return t.defaultProps={api:void 0,headers:{},loader:void 0,onIntercept:void 0,store:void 0,timeout:void 0},t.contextTypes={store:s},t.childContextTypes={rdfApi:i.string,rdfHeaders:i.object,rdfInterceptor:i.func,rdfLoader:i.oneOfType([i.element,i.func]),rdfStore:i.object,rdfTimeout:i.number},t}(),y=r(function(t){!function(e){var r,o=Object.prototype,n=o.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",s=i.asyncIterator||"@@asyncIterator",c=i.toStringTag||"@@toStringTag",u=e.regeneratorRuntime;if(u)t.exports=u;else{(u=e.regeneratorRuntime=t.exports).wrap=_;var p="suspendedStart",f="suspendedYield",d="executing",h="completed",l={},y={};y[a]=function(){return this};var m=Object.getPrototypeOf,v=m&&m(m(A([])));v&&v!==o&&n.call(v,a)&&(y=v);var g=T.prototype=w.prototype=Object.create(y);O.prototype=g.constructor=T,T.constructor=O,T[c]=O.displayName="GeneratorFunction",u.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===O||"GeneratorFunction"===(e.displayName||e.name))},u.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,T):(t.__proto__=T,c in t||(t[c]="GeneratorFunction")),t.prototype=Object.create(g),t},u.awrap=function(t){return{__await:t}},x(L.prototype),L.prototype[s]=function(){return this},u.AsyncIterator=L,u.async=function(t,e,r,o){var n=new L(_(t,e,r,o));return u.isGeneratorFunction(e)?n:n.next().then(function(t){return t.done?t.value:n.next()})},x(g),g[c]="Generator",g[a]=function(){return this},g.toString=function(){return"[object Generator]"},u.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var o=e.pop();if(o in t)return r.value=o,r.done=!1,r}return r.done=!0,r}},u.values=A,j.prototype={constructor:j,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=r,this.done=!1,this.delegate=null,this.method="next",this.arg=r,this.tryEntries.forEach(P),!t)for(var e in this)"t"===e.charAt(0)&&n.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=r)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function o(o,n){return s.type="throw",s.arg=t,e.next=o,n&&(e.method="next",e.arg=r),!!n}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],s=a.completion;if("root"===a.tryLoc)return o("end");if(a.tryLoc<=this.prev){var c=n.call(a,"catchLoc"),u=n.call(a,"finallyLoc");if(c&&u){if(this.prev<a.catchLoc)return o(a.catchLoc,!0);if(this.prev<a.finallyLoc)return o(a.finallyLoc)}else if(c){if(this.prev<a.catchLoc)return o(a.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return o(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,l):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),l},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),P(r),l}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var o=r.completion;if("throw"===o.type){var n=o.arg;P(r)}return n}}throw new Error("illegal catch attempt")},delegateYield:function(t,e,o){return this.delegate={iterator:A(t),resultName:e,nextLoc:o},"next"===this.method&&(this.arg=r),l}}}function _(t,e,r,o){var n=e&&e.prototype instanceof w?e:w,i=Object.create(n.prototype),a=new j(o||[]);return i._invoke=function(t,e,r){var o=p;return function(n,i){if(o===d)throw new Error("Generator is already running");if(o===h){if("throw"===n)throw i;return F()}for(r.method=n,r.arg=i;;){var a=r.delegate;if(a){var s=E(a,r);if(s){if(s===l)continue;return s}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(o===p)throw o=h,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);o=d;var c=b(t,e,r);if("normal"===c.type){if(o=r.done?h:f,c.arg===l)continue;return{value:c.arg,done:r.done}}"throw"===c.type&&(o=h,r.method="throw",r.arg=c.arg)}}}(t,r,a),i}function b(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}function w(){}function O(){}function T(){}function x(t){["next","throw","return"].forEach(function(e){t[e]=function(t){return this._invoke(e,t)}})}function L(t){var e;this._invoke=function(r,o){function i(){return new Promise(function(e,i){!function e(r,o,i,a){var s=b(t[r],t,o);if("throw"!==s.type){var c=s.arg,u=c.value;return u&&"object"==typeof u&&n.call(u,"__await")?Promise.resolve(u.__await).then(function(t){e("next",t,i,a)},function(t){e("throw",t,i,a)}):Promise.resolve(u).then(function(t){c.value=t,i(c)},a)}a(s.arg)}(r,o,e,i)})}return e=e?e.then(i,i):i()}}function E(t,e){var o=t.iterator[e.method];if(o===r){if(e.delegate=null,"throw"===e.method){if(t.iterator.return&&(e.method="return",e.arg=r,E(t,e),"throw"===e.method))return l;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return l}var n=b(o,t.iterator,e.arg);if("throw"===n.type)return e.method="throw",e.arg=n.arg,e.delegate=null,l;var i=n.arg;return i?i.done?(e[t.resultName]=i.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=r),e.delegate=null,l):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,l)}function S(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function P(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function j(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(S,this),this.reset(!0)}function A(t){if(t){var e=t[a];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var o=-1,i=function e(){for(;++o<t.length;)if(n.call(t,o))return e.value=t[o],e.done=!1,e;return e.value=r,e.done=!0,e};return i.next=i}}return{next:F}}function F(){return{value:r,done:!0}}}(function(){return this}()||Function("return this")())}),m=function(){return this}()||Function("return this")(),v=m.regeneratorRuntime&&Object.getOwnPropertyNames(m).indexOf("regeneratorRuntime")>=0,g=v&&m.regeneratorRuntime;m.regeneratorRuntime=void 0;var _=y;if(v)m.regeneratorRuntime=g;else try{delete m.regeneratorRuntime}catch(t){m.regeneratorRuntime=void 0}var b=_,w=function t(e){var r,o,n=e.body,i=e.headers,a=e.method,s=e.onProgress,c=void 0===s?function(){return null}:s,p=e.onTimeout,d=e.params,h=e.onIntercept,l=e.url,y=e.timeout,m=void 0===y?0:y,v={Accept:"application/json;charset=UTF-8","Content-Type":"FORM_DATA"===a?"multipart/form-data":"application/json"},g=new FormData,_=l,w=null,O=(r=u(b.mark(function t(e,r,o){return b.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:o({response:r.response,request:r});case 1:case"end":return t.stop()}},t,void 0)})),function(t,e,o){return r.apply(this,arguments)}),T=function(t,e){t.abort(),p&&p(),e("Your request took more than "+m+"ms to resolve.")},x=(o=u(b.mark(function r(o,n,i){var a,s,c;return b.wrap(function(r){for(;;)switch(r.prev=r.next){case 0:if(4===o.readyState)if(a=o.status>=200&&o.status<=299){s=void 0;try{o.responseText&&(s=JSON.parse(o.responseText))}catch(t){s=o.responseText}c={data:s,isOK:a,request:o,status:o.status},n(c)}else h&&(w=h({currentParams:e,request:o,status:o.status}))?n(t(f({},w,{onIntercept:void 0}))):O(o,o,i);case 1:case"end":return r.stop()}},r,void 0)})),function(t,e,r){return o.apply(this,arguments)});"FORM_DATA"===a&&Object.entries(n).length>0&&Object.entries(n).map(function(t){return g.append(t[0],t[1])}),d&&Object.keys(d).length>0&&Object.entries(d).map(function(t,e){return _=0===e?_+"?"+t[0]+"="+JSON.stringify(t[1]):_+"&"+t[0]+"="+JSON.stringify(t[1])});return new Promise(function(t,e){try{var r=new XMLHttpRequest;r.upload&&(r.upload.onerror=function(e){return O(e,r,t)},r.upload.onload=function(){return x(r,t,e)},r.upload.onprogress=c,r.upload.ontimeout=function(){return T(r,e)}),r.onerror=function(e){return O(e,r,t)},r.onprogress=c,r.onreadystatechange=function(){return x(r,t,e)},r.ontimeout=function(){return T(r,e)},r.open("FORM_DATA"===a?"POST":a,_),r.timeout=m,function(t){Object.entries(v).map(function(e){return t.setRequestHeader(e[0],String(e[1]))}),i&&Object.keys(i).length>0&&Object.entries(i).map(function(e){return t.setRequestHeader(e[0],String(e[1]))})}(r),r.send("FORM_DATA"===a?g:"DELETE"===a||"GET"===a||"HEAD"===a||"PUT"===a?null:JSON.stringify(f({},n)))}catch(r){O(r,r,e)}})},O=function(t){function r(){var e,o,n,i=this;p(this,r);for(var s=arguments.length,d=Array(s),l=0;l<s;l++)d[l]=arguments[l];return e=o=h(this,t.call.apply(t,[this].concat(d))),o._data=void 0,o._didCallOnLoad=!1,o._isLoaded=!1,o._isUnmounted=!1,o._fetchData=(n=u(b.mark(function t(e,r){var n,a,s,c,u,p,d,h,l,y,m,v,g;return b.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=e.body,a=e.headers,s=e.method,c=e.onIntercept,u=e.onProgress,p=e.onTimeout,d=e.params,h=e.path,l=e.url,y=e.timeout,m=void 0,v=0,m=h?""+(r.rdfApi||"")+h:l,r.rdfTimeout&&-1===y?v=r.rdfTimeout:!r.rdfTimeout&&y?v=Math.max(0,y):r.rdfTimeout&&y&&(v=-1===y?r.rdfTimeout:y),t.prev=5,t.next=8,w({url:m||"",body:f({},n),headers:f({},r.rdfHeaders,a),method:s,onTimeout:p,onProgress:u,onIntercept:c||r.rdfInterceptor,params:f({},d),timeout:v});case 8:g=t.sent,o._isUnmounted||o._handleData(f({},g,{store:r.rdfStore})),t.next=15;break;case 12:t.prev=12,t.t0=t.catch(5),o._isUnmounted||o._handleData({error:{content:t.t0,message:"Something went wrong during the request",url:m},isOK:!1,store:r.rdfStore});case 15:case"end":return t.stop()}},t,i,[[5,12]])})),function(t,e){return n.apply(this,arguments)}),o._handleData=function(t){o._isUnmounted||(o._isLoaded=!0,o.props.resultOnly?o._data=t.error||t.data:o._data=t,o._returnData(t))},o._printError=function(t){return t.response&&JSON.stringify(t.response).length?"string"==typeof t.response?t.response:"object"===c(t.response)?JSON.stringify(t.response,null,2):t.response+". Sorry <Fetch /> couldn't turned this into a readable string. Check error.content.request to see what happened.":" .Sorry <Fetch /> couldn't turned this into a readable string. Check error.content.request to see what happened."},o._renderLoader=function(){var t=o.context.rdfLoader,e=o.props.loader;return t&&!e?"function"==typeof t?t():t:!t&&e?"function"==typeof e?e():e:t&&e?"function"==typeof e?e():e:null},o._returnData=function(t){var e=o.props,r=e.onError,n=e.onFetch;n&&n(o._data),t.error&&r&&r(o._data),o._isUnmounted||o.forceUpdate()},o._validateProps=function(t,e){var r=e.rdfApi,o=e.rdfStore,n=e.rdfTimeout,i=t.children,s=t.component,c=t.onTimeout,u=t.onFetch,p=t.path,f=(t.refetch,t.render),d=t.timeout,h=t.url;p||h||("production"!==process.env.NODE_ENV?a(!1,"You must provide a `url` or a `path` to <Fetch />"):a(!1)),p&&(p&&r||("production"!==process.env.NODE_ENV?a(!1,"You must implement <FetchProvider> at the root of your app and provide an `api` in order to use `path`"):a(!1))),"store"===p&&(p&&o||("production"!==process.env.NODE_ENV?a(!1,'You must implement <FetchProvider> at the root of your app and provide a `store` in order to use `path="store"`'):a(!1))),c&&("number"==typeof d&&d>=0||"number"==typeof n&&n>=0||("production"!==process.env.NODE_ENV?a(!1,"You must provide a `timeout` number in ms to <Fetch /> or <FetchProvider> in order to use `onTimeout`"):a(!1))),i||s||f||u||("production"!==process.env.NODE_ENV?a(!1,"You must provide at least one of the following to <Fetch />: children, `component`, `onFetch`, `render`"):a(!1))},h(o,e)}return d(r,t),r.prototype.componentWillMount=function(){this._validateProps(this.props,this.context),this.props.onLoad&&!this._didCallOnLoad&&(this._didCallOnLoad=!0,this.props.onLoad())},r.prototype.componentDidMount=function(){"store"===this.props.path?this._handleData({data:this.context.rdfStore,isOK:!0}):this._fetchData(this.props,this.context)},r.prototype.componentWillReceiveProps=function(t,e){var r=this.props,o=r.onLoad,n=r.path,i=r.refetch,a=r.refetchKey;this._validateProps(t,e),o&&!this._didCallOnLoad&&(this._didCallOnLoad=!0,o()),"store"===n?this._handleData({data:this.context.rdfStore,isOK:!0}):t.path===n&&t.refetch===i&&t.refetchKey===a||(this._isLoaded=!1,this._fetchData(t,e))},r.prototype.componentWillUnmount=function(){this._isUnmounted=!0},r.prototype.shouldComponentUpdate=function(t){return this.props.children!==t.children||(this.props.loader!==t.loader||(this.props.onError!==t.onError||(this.props.onFetch!==t.onFetch||(this.props.onLoad!==t.onLoad||(this.props.path!==t.path||(this.props.params!==t.params||(this.props.refetch!==t.refetch||(this.props.refetchKey!==t.refetchKey||(this.props.render!==t.render||(!!this._isLoaded||!!this._data))))))))))},r.prototype.render=function(){var t=this.props,r=t.children,o=t.component,n=t.render;if(!this._isLoaded&&!this._isUnmounted)return this._renderLoader();if(this._isLoaded&&!this._isUnmounted){if(o)return e.createElement(o,this._data);if("function"==typeof n)return n(this._data);if("function"==typeof r)return r(this._data);if(r&&!function(t){return 0===e.Children.count(t)}(r))return e.Children.only(r)}return null},r}(e.Component);O.contextTypes={rdfApi:i.string,rdfHeaders:i.object,rdfInterceptor:i.func,rdfLoader:i.oneOfType([i.element,i.func]),rdfStore:i.object,rdfTimeout:i.number},O.defaultProps={body:{},children:void 0,component:void 0,loader:void 0,method:"GET",onError:void 0,onFetch:void 0,onLoad:void 0,onProgress:void 0,onTimeout:void 0,params:{},path:void 0,refetch:void 0,refetchKey:void 0,render:void 0,resultOnly:!1,url:void 0,timeout:-1};var T=function(){var t=function(t){function r(){var e,o;p(this,r);for(var n=arguments.length,i=Array(n),a=0;a<n;a++)i[a]=arguments[a];return e=o=h(this,t.call.apply(t,[this].concat(i))),o.rdfApi=o.props.api,o.rdfHeaders=o.props.headers,o.rdfInterceptor=o.props.onIntercept,o.rdfLoader=o.props.loader,o.rdfStore=o.context&&o.context.store?o.context.store.getState():o.props.store,o.rdfTimeout=o.props.timeout,o.componentWillReceiveProps=function(){return null},h(o,e)}return d(r,t),r.prototype.getChildContext=function(){return{rdfApi:this.rdfApi||"",rdfHeaders:this.rdfHeaders,rdfInterceptor:this.rdfInterceptor,rdfLoader:this.rdfLoader,rdfStore:this.props.store||this.rdfStore,rdfTimeout:this.rdfTimeout}},r.prototype.render=function(){return e.Children.only(this.props.children)},r}(e.Component);return t.defaultProps={api:void 0,headers:{},loader:void 0,onIntercept:void 0,store:void 0,timeout:void 0},t.contextTypes={store:s},t.childContextTypes={rdfApi:i.string,rdfHeaders:i.object,rdfInterceptor:i.func,rdfLoader:i.oneOfType([i.element,i.func]),rdfStore:i.object,rdfTimeout:i.number},t}();t.ConnectedFetch=l,t.Fetch=O,t.FetchProvider=T,t.requestToApi=w,Object.defineProperty(t,"__esModule",{value:!0})});
+!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("react")):"function"==typeof define&&define.amd?define(["exports","react"],e):e(t.ReactDataFetching={},t.React)}(this,function(t,e){"use strict";function r(t,e){return t(e={exports:{}},e.exports),e.exports}var o="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";function n(){}var i=r(function(t){t.exports=function(){function t(t,e,r,n,i,a){if(a!==o){var s=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw s.name="Invariant Violation",s}}function e(){return t}t.isRequired=t;var r={array:t,bool:t,func:t,number:t,object:t,string:t,symbol:t,any:t,arrayOf:e,element:t,instanceOf:e,node:t,objectOf:e,oneOf:e,oneOfType:e,shape:e,exact:e};return r.checkPropTypes=n,r.PropTypes=r,r}()}),a=function(t,e,r,o,n,i,a,s){if(!t){var c;if(void 0===e)c=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else{var u=[r,o,n,i,a,s],p=0;(c=new Error(e.replace(/%s/g,function(){return u[p++]}))).name="Invariant Violation"}throw c.framesToPop=1,c}},s=(i.oneOf(["DELETE","FORM_DATA","GET","HEAD","PATCH","POST","PUT","TRACE"]),i.shape({getState:i.func})),c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},u=function(t){return function(){var e=t.apply(this,arguments);return new Promise(function(t,r){return function o(n,i){try{var a=e[n](i),s=a.value}catch(t){return void r(t)}if(!a.done)return Promise.resolve(s).then(function(t){o("next",t)},function(t){o("throw",t)});t(s)}("next")})}},p=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")},f=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var o in r)Object.prototype.hasOwnProperty.call(r,o)&&(t[o]=r[o])}return t},d=function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)},h=function(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e},l=function(){var t=function(t){function r(){var e,o;p(this,r);for(var n=arguments.length,i=Array(n),a=0;a<n;a++)i[a]=arguments[a];return e=o=h(this,t.call.apply(t,[this].concat(i))),o.rdfApi=o.props.api,o.rdfHeaders=o.props.headers,o.rdfInterceptor=o.props.onIntercept,o.rdfLoader=o.props.loader,o.rdfStore=o.context&&o.context.store?o.context.store.getState():o.props.store,o.rdfTimeou!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).ReactDataFetching=e()}(this,(function(){"use strict";function t(t,e,r,n,o,i,a){try{var u=t[i](a),c=u.value}catch(t){return void r(t)}u.done?e(c):Promise.resolve(c).then(n,o)}function e(e){return function(){var r=this,n=arguments;return new Promise((function(o,i){var a=e.apply(r,n);function u(e){t(a,o,i,u,c,"next",e)}function c(e){t(a,o,i,u,c,"throw",e)}u(void 0)}))}}function r(){return(r=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t}).apply(this,arguments)}var n=function(t,e){return t(e={exports:{}},e.exports),e.exports}((function(t){var e=function(t){var e=Object.prototype,r=e.hasOwnProperty,n="function"==typeof Symbol?Symbol:{},o=n.iterator||"@@iterator",i=n.asyncIterator||"@@asyncIterator",a=n.toStringTag||"@@toStringTag";function u(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{u({},"")}catch(t){u=function(t,e,r){return t[e]=r}}function c(t,e,r,n){var o=e&&e.prototype instanceof l?e:l,i=Object.create(o.prototype),a=new L(n||[]);return i._invoke=function(t,e,r){var n="suspendedStart";return function(o,i){if("executing"===n)throw new Error("Generator is already running");if("completed"===n){if("throw"===o)throw i;return j()}for(r.method=o,r.arg=i;;){var a=r.delegate;if(a){var u=x(a,r);if(u){if(u===f)continue;return u}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if("suspendedStart"===n)throw n="completed",r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n="executing";var c=s(t,e,r);if("normal"===c.type){if(n=r.done?"completed":"suspendedYield",c.arg===f)continue;return{value:c.arg,done:r.done}}"throw"===c.type&&(n="completed",r.method="throw",r.arg=c.arg)}}}(t,r,a),i}function s(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=c;var f={};function l(){}function h(){}function p(){}var d={};d[o]=function(){return this};var y=Object.getPrototypeOf,v=y&&y(y(E([])));v&&v!==e&&r.call(v,o)&&(d=v);var g=p.prototype=l.prototype=Object.create(d);function m(t){["next","throw","return"].forEach((function(e){u(t,e,(function(t){return this._invoke(e,t)}))}))}function w(t,e){var n;this._invoke=function(o,i){function a(){return new e((function(n,a){!function n(o,i,a,u){var c=s(t[o],t,i);if("throw"!==c.type){var f=c.arg,l=f.value;return l&&"object"==typeof l&&r.call(l,"__await")?e.resolve(l.__await).then((function(t){n("next",t,a,u)}),(function(t){n("throw",t,a,u)})):e.resolve(l).then((function(t){f.value=t,a(f)}),(function(t){return n("throw",t,a,u)}))}u(c.arg)}(o,i,n,a)}))}return n=n?n.then(a,a):a()}}function x(t,e){var r=t.iterator[e.method];if(undefined===r){if(e.delegate=null,"throw"===e.method){if(t.iterator.return&&(e.method="return",e.arg=undefined,x(t,e),"throw"===e.method))return f;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return f}var n=s(r,t.iterator,e.arg);if("throw"===n.type)return e.method="throw",e.arg=n.arg,e.delegate=null,f;var o=n.arg;return o?o.done?(e[t.resultName]=o.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=undefined),e.delegate=null,f):o:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,f)}function b(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function O(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function L(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(b,this),this.reset(!0)}function E(t){if(t){var e=t[o];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,i=function e(){for(;++n<t.length;)if(r.call(t,n))return e.value=t[n],e.done=!1,e;return e.value=undefined,e.done=!0,e};return i.next=i}}return{next:j}}function j(){return{value:undefined,done:!0}}return h.prototype=g.constructor=p,p.constructor=h,h.displayName=u(p,a,"GeneratorFunction"),t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===h||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,p):(t.__proto__=p,u(t,a,"GeneratorFunction")),t.prototype=Object.create(g),t},t.awrap=function(t){return{__await:t}},m(w.prototype),w.prototype[i]=function(){return this},t.AsyncIterator=w,t.async=function(e,r,n,o,i){void 0===i&&(i=Promise);var a=new w(c(e,r,n,o),i);return t.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},m(g),u(g,a,"Generator"),g[o]=function(){return this},g.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=E,L.prototype={constructor:L,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=undefined,this.done=!1,this.delegate=null,this.method="next",this.arg=undefined,this.tryEntries.forEach(O),!t)for(var e in this)"t"===e.charAt(0)&&r.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=undefined)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function n(r,n){return a.type="throw",a.arg=t,e.next=r,n&&(e.method="next",e.arg=undefined),!!n}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=r.call(i,"catchLoc"),c=r.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,e){for(var n=this.tryEntries.length-1;n>=0;--n){var o=this.tryEntries[n];if(o.tryLoc<=this.prev&&r.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,f):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),f},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),O(r),f}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;O(r)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(t,e,r){return this.delegate={iterator:E(t),resultName:e,nextLoc:r},"next"===this.method&&(this.arg=undefined),f}},t}(t.exports);try{regeneratorRuntime=e}catch(t){Function("r","regeneratorRuntime = r")(e)}}));return function t(o){var i=o.body,a=o.cancel,u=o.headers,c=o.method,s=o.onProgress,f=void 0===s?function(){return null}:s,l=o.onTimeout,h=o.params,p=o.onIntercept,d=o.url,y=o.timeout,v=void 0===y?0:y,g=o.disableDefaultHeaders,m={Accept:"application/json;charset=UTF-8","Content-Type":"FORM_DATA"===c?"multipart/form-data":"application/json"},w=new FormData,x=d,b=null,O=function(){var t=e(n.mark((function t(e,r,o){return n.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:o({response:r.response,request:r});case 1:case"end":return t.stop()}}),t)})));return function(e,r,n){return t.apply(this,arguments)}}(),L=function(t,e){t.abort(),l&&l(),e("Your request took more than "+v+"ms to resolve.")},E=function(){var i=e(n.mark((function e(i,a,u,c){var s,f,l;return n.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:if(c&&(s={data:{cancelled:!0},isOK:!0,request:i,status:i.status},a(s)),4!==i.readyState){e.next=20;break}if(!(f=i.status>=200&&i.status<=299)){e.next=19;break}if(!i.responseText){e.next=10;break}return e.next=7,JSON.parse(i.responseText);case 7:e.t0=e.sent,e.next=11;break;case 10:e.t0=void 0;case 11:e.t1=e.t0,e.t2=f,e.t3=i,e.t4=i.status,l={data:e.t1,isOK:e.t2,request:e.t3,status:e.t4},a(l),e.next=20;break;case 19:p&&(b=p({currentParams:o,request:i,status:i.status}))?a(t(r({},b,{onIntercept:void 0}))):O(i,i,u);case 20:case"end":return e.stop()}}),e)})));return function(t,e,r,n){return i.apply(this,arguments)}}();"FORM_DATA"===c&&Object.entries(i).length>0&&Object.entries(i).map((function(t){return w.append(t[0],t[1])})),h&&Object.keys(h).length>0&&Object.entries(h).map((function(t,e){return x=0===e?x+"?"+t[0]+"="+JSON.stringify(t[1]):x+"&"+t[0]+"="+JSON.stringify(t[1])}));return new Promise((function(t,e){try{var n=new XMLHttpRequest;n.upload&&(n.upload.onerror=function(e){return O(e,n,t)},n.upload.onload=function(){return E(n,t,e)},n.upload.onprogress=f,n.upload.ontimeout=function(){return L(n,e)}),n.onerror=function(e){return O(e,n,t)},n.onprogress=f,n.onreadystatechange=function(){return E(n,t,e)},n.ontimeout=function(){return L(n,e)},n.open("FORM_DATA"===c?"POST":c,x),n.timeout=v,function(t){g||Object.entries(m).map((function(e){return t.setRequestHeader(e[0],String(e[1]))})),u&&Object.keys(u).length>0&&Object.entries(u).map((function(e){return t.setRequestHeader(e[0],String(e[1]))}))}(n),a&&E(n,t,e,!0),n.send("FORM_DATA"===c?w:"DELETE"===c||"HEAD"===c?null:JSON.stringify(r({},i))),a&&n.abort()}catch(n){O(n,n,e)}}))}}));
+t=o.props.timeout,o.componentWillReceiveProps=function(){return null},h(o,e)}return d(r,t),r.prototype.componentDidMount=function(){},r.prototype.getChildContext=function(){return{rdfApi:this.rdfApi||"",rdfHeaders:this.rdfHeaders,rdfInterceptor:this.rdfInterceptor,rdfLoader:this.rdfLoader,rdfStore:this.props.store||this.rdfStore,rdfTimeout:this.rdfTimeout}},r.prototype.render=function(){return e.Children.only(this.props.children)},r}(e.Component);return t.defaultProps={api:void 0,headers:{},loader:void 0,onIntercept:void 0,store:void 0,timeout:void 0},t.contextTypes={store:s},t.childContextTypes={rdfApi:i.string,rdfHeaders:i.object,rdfInterceptor:i.func,rdfLoader:i.oneOfType([i.element,i.func]),rdfStore:i.object,rdfTimeout:i.number},t}(),y=r(function(t){!function(e){var r,o=Object.prototype,n=o.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",s=i.asyncIterator||"@@asyncIterator",c=i.toStringTag||"@@toStringTag",u=e.regeneratorRuntime;if(u)t.exports=u;else{(u=e.regeneratorRuntime=t.exports).wrap=_;var p="suspendedStart",f="suspendedYield",d="executing",h="completed",l={},y={};y[a]=function(){return this};var m=Object.getPrototypeOf,v=m&&m(m(A([])));v&&v!==o&&n.call(v,a)&&(y=v);var g=T.prototype=w.prototype=Object.create(y);O.prototype=g.constructor=T,T.constructor=O,T[c]=O.displayName="GeneratorFunction",u.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===O||"GeneratorFunction"===(e.displayName||e.name))},u.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,T):(t.__proto__=T,c in t||(t[c]="GeneratorFunction")),t.prototype=Object.create(g),t},u.awrap=function(t){return{__await:t}},x(L.prototype),L.prototype[s]=function(){return this},u.AsyncIterator=L,u.async=function(t,e,r,o){var n=new L(_(t,e,r,o));return u.isGeneratorFunction(e)?n:n.next().then(function(t){return t.done?t.value:n.next()})},x(g),g[c]="Generator",g[a]=function(){return this},g.toString=function(){return"[object Generator]"},u.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var o=e.pop();if(o in t)return r.value=o,r.done=!1,r}return r.done=!0,r}},u.values=A,j.prototype={constructor:j,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=r,this.done=!1,this.delegate=null,this.method="next",this.arg=r,this.tryEntries.forEach(P),!t)for(var e in this)"t"===e.charAt(0)&&n.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=r)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function o(o,n){return s.type="throw",s.arg=t,e.next=o,n&&(e.method="next",e.arg=r),!!n}for(var i=this.tryEntries.length-1;i>=0;--i){var a=this.tryEntries[i],s=a.completion;if("root"===a.tryLoc)return o("end");if(a.tryLoc<=this.prev){var c=n.call(a,"catchLoc"),u=n.call(a,"finallyLoc");if(c&&u){if(this.prev<a.catchLoc)return o(a.catchLoc,!0);if(this.prev<a.finallyLoc)return o(a.finallyLoc)}else if(c){if(this.prev<a.catchLoc)return o(a.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return o(a.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,l):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),l},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),P(r),l}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var o=r.completion;if("throw"===o.type){var n=o.arg;P(r)}return n}}throw new Error("illegal catch attempt")},delegateYield:function(t,e,o){return this.delegate={iterator:A(t),resultName:e,nextLoc:o},"next"===this.method&&(this.arg=r),l}}}function _(t,e,r,o){var n=e&&e.prototype instanceof w?e:w,i=Object.create(n.prototype),a=new j(o||[]);return i._invoke=function(t,e,r){var o=p;return function(n,i){if(o===d)throw new Error("Generator is already running");if(o===h){if("throw"===n)throw i;return F()}for(r.method=n,r.arg=i;;){var a=r.delegate;if(a){var s=E(a,r);if(s){if(s===l)continue;return s}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(o===p)throw o=h,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);o=d;var c=b(t,e,r);if("normal"===c.type){if(o=r.done?h:f,c.arg===l)continue;return{value:c.arg,done:r.done}}"throw"===c.type&&(o=h,r.method="throw",r.arg=c.arg)}}}(t,r,a),i}function b(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}function w(){}function O(){}function T(){}function x(t){["next","throw","return"].forEach(function(e){t[e]=function(t){return this._invoke(e,t)}})}function L(t){var e;this._invoke=function(r,o){function i(){return new Promise(function(e,i){!function e(r,o,i,a){var s=b(t[r],t,o);if("throw"!==s.type){var c=s.arg,u=c.value;return u&&"object"==typeof u&&n.call(u,"__await")?Promise.resolve(u.__await).then(function(t){e("next",t,i,a)},function(t){e("throw",t,i,a)}):Promise.resolve(u).then(function(t){c.value=t,i(c)},a)}a(s.arg)}(r,o,e,i)})}return e=e?e.then(i,i):i()}}function E(t,e){var o=t.iterator[e.method];if(o===r){if(e.delegate=null,"throw"===e.method){if(t.iterator.return&&(e.method="return",e.arg=r,E(t,e),"throw"===e.method))return l;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return l}var n=b(o,t.iterator,e.arg);if("throw"===n.type)return e.method="throw",e.arg=n.arg,e.delegate=null,l;var i=n.arg;return i?i.done?(e[t.resultName]=i.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=r),e.delegate=null,l):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,l)}function S(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function P(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function j(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(S,this),this.reset(!0)}function A(t){if(t){var e=t[a];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var o=-1,i=function e(){for(;++o<t.length;)if(n.call(t,o))return e.value=t[o],e.done=!1,e;return e.value=r,e.done=!0,e};return i.next=i}}return{next:F}}function F(){return{value:r,done:!0}}}(function(){return this}()||Function("return this")())}),m=function(){return this}()||Function("return this")(),v=m.regeneratorRuntime&&Object.getOwnPropertyNames(m).indexOf("regeneratorRuntime")>=0,g=v&&m.regeneratorRuntime;m.regeneratorRuntime=void 0;var _=y;if(v)m.regeneratorRuntime=g;else try{delete m.regeneratorRuntime}catch(t){m.regeneratorRuntime=void 0}var b=_,w=function t(e){var r,o,n=e.body,i=e.headers,a=e.method,s=e.onProgress,c=void 0===s?function(){return null}:s,p=e.onTimeout,d=e.params,h=e.onIntercept,l=e.url,y=e.timeout,m=void 0===y?0:y,v={Accept:"application/json;charset=UTF-8","Content-Type":"FORM_DATA"===a?"multipart/form-data":"application/json"},g=new FormData,_=l,w=null,O=(r=u(b.mark(function t(e,r,o){return b.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:o({response:r.response,request:r});case 1:case"end":return t.stop()}},t,void 0)})),function(t,e,o){return r.apply(this,arguments)}),T=function(t,e){t.abort(),p&&p(),e("Your request took more than "+m+"ms to resolve.")},x=(o=u(b.mark(function r(o,n,i){var a,s,c;return b.wrap(function(r){for(;;)switch(r.prev=r.next){case 0:if(4===o.readyState)if(a=o.status>=200&&o.status<=299){s=void 0;try{o.responseText&&(s=JSON.parse(o.responseText))}catch(t){s=o.responseText}c={data:s,isOK:a,request:o,status:o.status},n(c)}else h&&(w=h({currentParams:e,request:o,status:o.status}))?n(t(f({},w,{onIntercept:void 0}))):O(o,o,i);case 1:case"end":return r.stop()}},r,void 0)})),function(t,e,r){return o.apply(this,arguments)});"FORM_DATA"===a&&Object.entries(n).length>0&&Object.entries(n).map(function(t){return g.append(t[0],t[1])}),d&&Object.keys(d).length>0&&Object.entries(d).map(function(t,e){return _=0===e?_+"?"+t[0]+"="+JSON.stringify(t[1]):_+"&"+t[0]+"="+JSON.stringify(t[1])});return new Promise(function(t,e){try{var r=new XMLHttpRequest;r.upload&&(r.upload.onerror=function(e){return O(e,r,t)},r.upload.onload=function(){return x(r,t,e)},r.upload.onprogress=c,r.upload.ontimeout=function(){return T(r,e)}),r.onerror=function(e){return O(e,r,t)},r.onprogress=c,r.onreadystatechange=function(){return x(r,t,e)},r.ontimeout=function(){return T(r,e)},r.open("FORM_DATA"===a?"POST":a,_),r.timeout=m,function(t){Object.entries(v).map(function(e){return t.setRequestHeader(e[0],String(e[1]))}),i&&Object.keys(i).length>0&&Object.entries(i).map(function(e){return t.setRequestHeader(e[0],String(e[1]))})}(r),r.send("FORM_DATA"===a?g:"DELETE"===a||"HEAD"===a?null:JSON.stringify(f({},n)))}catch(r){O(r,r,e)}})},O=function(t){function r(){var e,o,n,i=this;p(this,r);for(var s=arguments.length,d=Array(s),l=0;l<s;l++)d[l]=arguments[l];return e=o=h(this,t.call.apply(t,[this].concat(d))),o._data=void 0,o._didCallOnLoad=!1,o._isLoaded=!1,o._isUnmounted=!1,o._fetchData=(n=u(b.mark(function t(e,r){var n,a,s,c,u,p,d,h,l,y,m,v,g;return b.wrap(function(t){for(;;)switch(t.prev=t.next){case 0:return n=e.body,a=e.headers,s=e.method,c=e.onIntercept,u=e.onProgress,p=e.onTimeout,d=e.params,h=e.path,l=e.url,y=e.timeout,m=void 0,v=0,m=h?""+(r.rdfApi||"")+h:l,r.rdfTimeout&&-1===y?v=r.rdfTimeout:!r.rdfTimeout&&y?v=Math.max(0,y):r.rdfTimeout&&y&&(v=-1===y?r.rdfTimeout:y),t.prev=5,t.next=8,w({url:m||"",body:f({},n),headers:f({},r.rdfHeaders,a),method:s,onTimeout:p,onProgress:u,onIntercept:c||r.rdfInterceptor,params:f({},d),timeout:v});case 8:g=t.sent,o._isUnmounted||o._handleData(f({},g,{store:r.rdfStore})),t.next=15;break;case 12:t.prev=12,t.t0=t.catch(5),o._isUnmounted||o._handleData({error:{content:t.t0,message:"Something went wrong during the request",url:m},isOK:!1,store:r.rdfStore});case 15:case"end":return t.stop()}},t,i,[[5,12]])})),function(t,e){return n.apply(this,arguments)}),o._handleData=function(t){o._isUnmounted||(o._isLoaded=!0,o.props.resultOnly?o._data=t.error||t.data:o._data=t,o._returnData(t))},o._printError=function(t){return t.response&&JSON.stringify(t.response).length?"string"==typeof t.response?t.response:"object"===c(t.response)?JSON.stringify(t.response,null,2):t.response+". Sorry <Fetch /> couldn't turned this into a readable string. Check error.content.request to see what happened.":" .Sorry <Fetch /> couldn't turned this into a readable string. Check error.content.request to see what happened."},o._renderLoader=function(){var t=o.context.rdfLoader,e=o.props.loader;return t&&!e?"function"==typeof t?t():t:!t&&e?"function"==typeof e?e():e:t&&e?"function"==typeof e?e():e:null},o._returnData=function(t){var e=o.props,r=e.onError,n=e.onFetch;n&&n(o._data),t.error&&r&&r(o._data),o._isUnmounted||o.forceUpdate()},o._validateProps=function(t,e){var r=e.rdfApi,o=e.rdfStore,n=e.rdfTimeout,i=t.children,s=t.component,c=t.onTimeout,u=t.onFetch,p=t.path,f=(t.refetch,t.render),d=t.timeout,h=t.url;p||h||("production"!==process.env.NODE_ENV?a(!1,"You must provide a `url` or a `path` to <Fetch />"):a(!1)),p&&(p&&r||("production"!==process.env.NODE_ENV?a(!1,"You must implement <FetchProvider> at the root of your app and provide an `api` in order to use `path`"):a(!1))),"store"===p&&(p&&o||("production"!==process.env.NODE_ENV?a(!1,'You must implement <FetchProvider> at the root of your app and provide a `store` in order to use `path="store"`'):a(!1))),c&&("number"==typeof d&&d>=0||"number"==typeof n&&n>=0||("production"!==process.env.NODE_ENV?a(!1,"You must provide a `timeout` number in ms to <Fetch /> or <FetchProvider> in order to use `onTimeout`"):a(!1))),i||s||f||u||("production"!==process.env.NODE_ENV?a(!1,"You must provide at least one of the following to <Fetch />: children, `component`, `onFetch`, `render`"):a(!1))},h(o,e)}return d(r,t),r.prototype.componentWillMount=function(){this._validateProps(this.props,this.context),this.props.onLoad&&!this._didCallOnLoad&&(this._didCallOnLoad=!0,this.props.onLoad())},r.prototype.componentDidMount=function(){"store"===this.props.path?this._handleData({data:this.context.rdfStore,isOK:!0}):this._fetchData(this.props,this.context)},r.prototype.componentWillReceiveProps=function(t,e){var r=this.props,o=r.onLoad,n=r.path,i=r.refetch,a=r.refetchKey;this._validateProps(t,e),o&&!this._didCallOnLoad&&(this._didCallOnLoad=!0,o()),"store"===n?this._handleData({data:this.context.rdfStore,isOK:!0}):t.path===n&&t.refetch===i&&t.refetchKey===a||(this._isLoaded=!1,this._fetchData(t,e))},r.prototype.componentWillUnmount=function(){this._isUnmounted=!0},r.prototype.shouldComponentUpdate=function(t){return this.props.children!==t.children||(this.props.loader!==t.loader||(this.props.onError!==t.onError||(this.props.onFetch!==t.onFetch||(this.props.onLoad!==t.onLoad||(this.props.path!==t.path||(this.props.params!==t.params||(this.props.refetch!==t.refetch||(this.props.refetchKey!==t.refetchKey||(this.props.render!==t.render||(!!this._isLoaded||!!this._data))))))))))},r.prototype.render=function(){var t=this.props,r=t.children,o=t.component,n=t.render;if(!this._isLoaded&&!this._isUnmounted)return this._renderLoader();if(this._isLoaded&&!this._isUnmounted){if(o)return e.createElement(o,this._data);if("function"==typeof n)return n(this._data);if("function"==typeof r)return r(this._data);if(r&&!function(t){return 0===e.Children.count(t)}(r))return e.Children.only(r)}return null},r}(e.Component);O.contextTypes={rdfApi:i.string,rdfHeaders:i.object,rdfInterceptor:i.func,rdfLoader:i.oneOfType([i.element,i.func]),rdfStore:i.object,rdfTimeout:i.number},O.defaultProps={body:{},children:void 0,component:void 0,loader:void 0,method:"GET",onError:void 0,onFetch:void 0,onLoad:void 0,onProgress:void 0,onTimeout:void 0,params:{},path:void 0,refetch:void 0,refetchKey:void 0,render:void 0,resultOnly:!1,url:void 0,timeout:-1};var T=function(){var t=function(t){function r(){var e,o;p(this,r);for(var n=arguments.length,i=Array(n),a=0;a<n;a++)i[a]=arguments[a];return e=o=h(this,t.call.apply(t,[this].concat(i))),o.rdfApi=o.props.api,o.rdfHeaders=o.props.headers,o.rdfInterceptor=o.props.onIntercept,o.rdfLoader=o.props.loader,o.rdfStore=o.context&&o.context.store?o.context.store.getState():o.props.store,o.rdfTimeout=o.props.timeout,o.componentWillReceiveProps=function(){return null},h(o,e)}return d(r,t),r.prototype.getChildContext=function(){return{rdfApi:this.rdfApi||"",rdfHeaders:this.rdfHeaders,rdfInterceptor:this.rdfInterceptor,rdfLoader:this.rdfLoader,rdfStore:this.props.store||this.rdfStore,rdfTimeout:this.rdfTimeout}},r.prototype.render=function(){return e.Children.only(this.props.children)},r}(e.Component);return t.defaultProps={api:void 0,headers:{},loader:void 0,onIntercept:void 0,store:void 0,timeout:void 0},t.contextTypes={store:s},t.childContextTypes={rdfApi:i.string,rdfHeaders:i.object,rdfInterceptor:i.func,rdfLoader:i.oneOfType([i.element,i.func]),rdfStore:i.object,rdfTimeout:i.number},t}();t.ConnectedFetch=l,t.Fetch=O,t.FetchProvider=T,t.requestToApi=w,Object.defineProperty(t,"__esModule",{value:!0})});
